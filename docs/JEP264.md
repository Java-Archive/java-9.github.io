# Platform Logging API and Service - LoggerFinder
This [JEP](http://openjdk.java.net/jeps/264) is flagged with **core-util.logging**.


The main thing of this JEP is providing a facade for logging. It is something like
sl4j but now as part of the JDK.

Now we have to give an answer to a few questions.

## How to define a Logger?
To define a Logger by yourself, you could implement the interface ```System.Logger ```.
With this you could implement a Debugging-Logger for you project or delegate to the Implementation you want to use
if there is nothing provided from the Logger-Framework itself.

```java
public class SysOutLogger implements System.Logger {
 
   @Override
   public String getName() {
     return SysOutLogger.class.getSimpleName();
   }
 
   @Override // this conf is useless ;-)
   public boolean isLoggable(Level level) {
     switch (level) {
       case OFF: return false; 
       case TRACE: return false;
       case DEBUG: return true;
       case INFO: return true;
       case WARNING: return false;
       case ERROR: return false;
       case ALL: return false;
       default:
         return true;
     }
   }
 
   @Override
   public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {
     System.out.printf("SysOutLogger: %s: \"%s\" with \"%s\"%n", level, msg, thrown);
   }
 
   @Override
   public void log(Level level, ResourceBundle bundle, String format, Object... params) {
     System.out.printf("SysOutLogger: %s: \"%s\"%n", level, format(format, params));
   }
 }
```
 

## How to declare this Logger so that it could be used?
After this we have to make sure the system will use this one.
For this you have to extend the class ```System.LoggerFinder```.
Here you have to decide what will be the right Logger instance. This could be different in 
in different situations. You could use this for a more dynamic 
behavior.

```java
public class SysOutLoggerFinder extends System.LoggerFinder {

  @Override
  public System.Logger getLogger(String name, Module module) {
    return new SysOutLogger();
  }
}
```

So far, so good..  but if you will try using it..  Nothing will happen.
You have to declare this as the active LoggingFinder.
The traditional way of doing it, would be a ServiceLocator. But with Java9 you could use
the file ```module-info.java```

```java
module org.rapidpm.workshop.java09.jep264.v001.logger {
  provides `
      with org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder;
}
```

Here you could see, that the interface ```java.lang.System.LoggerFinder```
will be connected with the implementation ```org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder```

Now you could use it.


```java
    final System.Logger logger = System.getLogger("LoggerName");
    System.out.println(logger.getName());
    System.out.println("logger = " + logger);

    final boolean loggable = logger.isLoggable(System.Logger.Level.DEBUG);
    System.out.println("loggable = " + loggable);

    logger.log(System.Logger.Level.DEBUG, () -> "logmessage");

```

The output would be something like the follwoing.

```text
SysOutLogger
logger = org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLogger@394e1a0f
loggable = true
SysOutLogger: x DEBUG: "logmessage"
```

## why we want to use Supplier?

LetÂ´s asume we want to log the following statement.

```java
String message = "here " + "are " + "expensive " + "ops " + methodToShowThePrice();

  private static String methodToShowThePrice() {
    System.out.println(" will create instance now.....");
    return LocalDateTime.now().toString();
  }
```

The Logger-Interface provides a few method signatures for the method ```log(..)```
The simple one is expecting a String as argument.

```java
        public default void log(Level level, String msg) {
            log(level, (ResourceBundle) null, msg, (Object[]) null);
        }
```
This means that you have to wrap the log-call into an if - statement to avoid useless
creations of the message String.

```java
    //log something
    if(logger.isLoggable(System.Logger.Level.DEBUG)) 
      logger.log(System.Logger.Level.DEBUG, "here " + "are " + "expensive " + "ops " + methodToShowThePrice());
    
    // Logger not working on this level
    if(logger.isLoggable(System.Logger.Level.TRACE))
      logger.log(System.Logger.Level.TRACE, "here " + "are " + "expensive " + "ops " + methodToShowThePrice());
```

But this could be written shorter if you are using Supplier.
First check the implementation of the log - method that will accept Supplier instead of a String.

```java
        public default void log(Level level, Supplier<String> msgSupplier) {
            Objects.requireNonNull(msgSupplier);
            if (isLoggable(Objects.requireNonNull(level))) {
                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);
            }
        }
```

Here you could see, that it will be checked if the logger is working with the given level.
So your code should look like one of the following lines..

```java
   // version one with on the fly Supplier
   logger.log(System.Logger.Level.DEBUG, ()-> "here " + "are " + "expensive " + "ops " + methodToShowThePrice());

  //version two with a global defined Supplier
  private Supplier<String> logMessage = ()-> "here " + "are " + "expensive " + "ops " + methodToShowThePrice();

  logger.log(System.Logger.Level.DEBUG, logMessage);
```


Happy logging......
