# Milling Project Coin
This [JEP](http://openjdk.java.net/jeps/213) is flagged wit **tools / javac**.

This JEP is divided in five parts. This is more or less a collections of improvements
of things we got with Java7 and Java8.

### Allow @SafeVargs on private instance methods. 
The @SafeVarargs annotation can only be applied to methods which cannot be overridden, 
like static final or public final methods.
With Java9 we could do this now with private methods, too.
Even if they are (static/unstatic) final or not.

```java
  @SafeVarargs
  public static <T> void myStaticMethod(T... args) {
    // don something
  }  
  
  @SafeVarargs
  public final <T> void myUnStaticMethod(T... args) {
    // don something
  }

  @SafeVarargs
  private final <T> void myPrivateUnStaticMethod(T... args) {
    // don something
  }

  @SafeVarargs
  private  <T> void myPrivateUnFinalUnStaticMethod(T... args) {
    // don something
  }

  @SafeVarargs
  private static final <T> void myPrivateStaticMethod(T... args) {
    // don something
  }

  @SafeVarargs
  private  static <T> void myPrivateUnFinalStaticMethod(T... args) {
    // don something
  }
```

### Allow effectively-final variables to be used as resources in the try-with-resources statement.
The target here was the reduction of boilderplate code. In Java7 and Java8 you had to write the following
lines to deal with an ```AutoClosable```

```java
  public void doSomethingWithOld(ByteArrayInputStream bais) throws Exception {
    try(final ByteArrayInputStream stream = bais) {
      final byte[] readAllBytes = stream.readAllBytes();
    }
  }  
```
In Java9 you could write it without declaring a new variable. But the attribute must be final or effectively final. 
> ***Remember:***
> A variable or parameter whose value is never changed after it is initialized is effectively final.

```java

  public void doSomethingWithOld(ByteArrayInputStream bais) throws Exception {
    try(final ByteArrayInputStream stream = bais) {
      final byte[] readAllBytes = stream.readAllBytes();
    }
  }  
  
  public void doSomethingWith(ByteArrayInputStream bais) throws Exception {
    try(bais) {
      final byte[] readAllBytes = bais.readAllBytes();
    }
  }
```

### Allow diamond with anonymous classes if the argument type of the inferred type is denotable.
This is a small change for Generics. 

```java
  //possible in Java8
  public <T> MySimpleInterface<T> createInterface(T value) {
    return () -> value;
  }

  //NOT possible in Java8
  public <T> MySimpleClass<T> create(T value) {
    //return new MySimpleClass<T>() {
    return new MySimpleClass<>() {
      @Override
      public T create() {
        return value;
      }
    };
  }


  private static abstract class MySimpleClass<T> {
    public abstract T create();
  }

  private interface MySimpleInterface<T> {
    T create();
  }
```
Up to Java8 you could not use a Diamond Operator at the line defining the inner anonymous class.
But with Java9 the type could be found at this place, and you could use the Diamond Operator.
But if you are using a Functional Interface, this was "possible" at the place you define the lambda expression.

### Complete the removal, begun in Java SE 8, of underscore from the set of legal identifier names.

This is quite simple to explain. The identifier "_" is not allowed anymore. In combination with other letters yes, 
but now as identifier alone.  

### Support for private methods in interfaces
Now we are able to provide private methods in interfaces. This private methods are accessible 
inside the interface, not in the implementing claas.
 
This will give you the possibility to give your default implementations a better structure compared to the 
Java8 version. 


```java
@FunctionalInterface
public interface Service {

  default void workOnDefault() {
    workA();
    workB();
    workC();
    //somethingHidden();
  }

  void workA();

  private void workB() {
    System.out.println("workB = ");
  }

  private static void workC() {
    System.out.println("workC ");
  }

  //private void somethingHidden(); // declaration only not possible
}
```

Have in mind, that a private declaration without a method body is not allowed. May the IDE is not complaining.
The same with overriding the private method declaration. This will not used from the default implementation.

```java
    final Service service01 = new Service() {

      @Override
      public void workA() { }

      private void workB() {
        //super.workB(); not possible
        // this implementation will not used from the default
        System.out.println("service01.workB() = ");
      }
    };
    service01.workOnDefault();
```

Or as Lambda.
```java
((Service)() -> { }).workOnDefault();
```
