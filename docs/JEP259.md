# Stack-Walking API
This [JEP](http://openjdk.java.net/jeps/259) is flagged wit **core**.

All source codes I am using here you could find under 

[github - java-9 / workshop_java09](https://github.com/java-9/workshop_java09/tree/develop/src/org/rapidpm/workshop/java09/jep259)

## StackWalker

The StackWalker will give you the information about the caller tree of your ethod you are just in.
To get an instance of the StackWalcker you can use a few ```getIntance(..)``` methods.

For this examples I created a class ```Holder``` to create a Stack you could walk through.
 
```java
 public static class Holder {
    private Holder holder;

    public Holder(final Holder holder) {
      this.holder = holder;
    }
    public void doWork() {
      if (Objects.isNull(holder)) {
        System.out.println("end reached..");
        StackWalker.getInstance().forEach(System.out::println);
      } else {
        holder.doWork();
      }
    }
  }
```

With this we are creating a well defined stack now.

```java
    new Holder(new Holder(new Holder(null) )).doWork();
```

The output here will be something like the following. Have in mind that I was starting this from inside IntelliJ

```text
end reached..
org.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)
org.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)
org.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)
org.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)
com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

### more detailed informations
You could get more informations out of the StackWalker as you saw before.
For this the class Holder will be extended now a little bit more.

```java
 public static class Holder002 {
    private Holder002 holder;

    public Holder002(final Holder002 holder) {
      this.holder = holder;
    }
    public void doWork() {
      if (Objects.isNull(holder)) {
        System.out.println("end reached..");
        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)
            .forEach(stackFrame -> {
              final int byteCodeIndex = stackFrame.getByteCodeIndex();
              System.out.println("byteCodeIndex = " + byteCodeIndex);
              // byteCode Index :
              final String className = stackFrame.getClassName();
              System.out.println("className = " + className);
              final Class<?> declaringClass = stackFrame.getDeclaringClass();
              System.out.println("declaringClass = " + declaringClass);
              final String fileName = stackFrame.getFileName();
              System.out.println("fileName = " + fileName);
              final int lineNumber = stackFrame.getLineNumber();
              System.out.println("lineNumber = " + lineNumber);
              final String methodName = stackFrame.getMethodName();
              System.out.println("methodName = " + methodName);
            });
      } else {
        holder.doWork();
      }
    }
  }
```

Here we have to use the first time a defined ```getInstance(..)``` method to get all informations. 
If you are not using the right ```StackWalker.Option``` the result will be an exception.
You have three Options.

* ***RETAIN_CLASS_REFERENCE:*** getCallerClass() and getDeclaringClass() will work

* ***SHOW_REFLECT_FRAMES:*** This will show all reflections frames that are hidden by default

* ***SHOW_HIDDEN_FRAMES:*** This will show all reflection frames and additionally implementation specific internal frames

Two things are not used in this example.
First is the method ```isNativeMethod()``` to identify if the caller method in the stack is a JVM native one 
and second ```toStackTraceElement()``` to convert this information to a StackTraceElement that you 
could use to generate a more detailed Exception-Message. 

```java
System.out.println("end reached..");
        final StackTraceElement[] stackTraceElements = StackWalker
            .getInstance()
            .walk(sfStream -> sfStream
                .takeWhile(frame -> frame.getClassName().startsWith("org.rapidpm"))
                .collect(Collectors.toList()))
            .stream()
            .map(StackWalker.StackFrame::toStackTraceElement)
            .toArray(StackTraceElement[]::new);

        try {
          final RuntimeException runtimeException = new RuntimeException();
          runtimeException.setStackTrace(stackTraceElements);
          throw runtimeException;
        } catch (Exception e) {
          e.printStackTrace();
        }
```
The output on my machine was.

```text
end reached..
java.lang.RuntimeException
	at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:41)
	at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)
	at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)
	at org.rapidpm.workshop.java09.jep259.JEP259V004.main(JEP259V004.java:26)
```


### filter the stack
Sometime you will have to filter a few of this information out that is given by the StackWalker.
For this you can work with the stream as done before at other places. The method ```walk(..)``` will 
give you the possibility to add a Predicate that will be used to filter the result.
Here I only want to have all elements from a specific namespace. 
(btw: the method ``takeWhile()```  is new too, check for this the section about Streams)

```java
StackWalker
            .getInstance()
            .walk(sfStream -> sfStream
                .takeWhile(frame -> frame.getClassName().startsWith("org.rapidpm"))
                .collect(Collectors.toList()))
            .forEach(System.out::println);
```

### sometimes you only want to know...

Yes, sometimes you only want to know the caller class. DonÂ´t worry, there is a simple solution.

```java
final Class<?> callerClass = StackWalker
        .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) //Option needed
        .getCallerClass();
    System.out.println("callerClass = " + callerClass);
```
