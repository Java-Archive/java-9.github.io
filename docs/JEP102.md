# Process API Updates
This [JEP](http://openjdk.java.net/jeps/102) is flagged with **core-lang**.


## java.lang.ProcessBuilder
### public static final Redirect DISCARD

If you are using the ProcessBuilder, you could define where 
the output will be redirected.
New here in Java 9 is ```dev/null``` ;-)

First we are writing all to the stdout.

```java
public static void main(String[] args) {
    final ProcessBuilder processBuilder = new ProcessBuilder();
    // only if installed
    final ProcessBuilder command = processBuilder.command("java", "-version"); 
    try {
      command
          .inheritIO()
          .redirectOutput(ProcessBuilder.Redirect.INHERIT)
          .redirectError(ProcessBuilder.Redirect.INHERIT);
      final Process start = command.start();
      final int waitFor = start.waitFor();
    } catch (IOException | InterruptedException e) {
      e.printStackTrace();
    }

  }
```
In this version you will see something like the following.

```text
java version "1.8.0_112"
Java(TM) SE Runtime Environment (build 1.8.0_112-b16)
Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)
```

If we are the new redirect we will see..... nothing...

```java
public static void main(String[] args) {
    final ProcessBuilder processBuilder = new ProcessBuilder();
    final ProcessBuilder command = processBuilder.command("java", "-version"); // only if installed
    try {
      command
          .inheritIO()
          .redirectOutput(ProcessBuilder.Redirect.DISCARD)
          .redirectError(ProcessBuilder.Redirect.DISCARD);
      final Process start = command.start();
      final int waitFor = start.waitFor();
    } catch (IOException | InterruptedException e) {
      e.printStackTrace();
    }
  }
```
## java.lang.ProcessHandle
With this we got a possibility to manage the process easy and a 
way to get information's about the started process itself.

First we will start to get some information's about the process itself we are running.
```java
    final ProcessHandle current = ProcessHandle.current();
    final long pid = current.getPid();
    System.out.println("pid = " + pid);
```
Here we are asking for the PID of our own process. But we could get easily 
a Stream of all running processes.

```java
    final Stream<ProcessHandle> processHandleStream = ProcessHandle.allProcesses();

    processHandleStream.forEach( p -> {
          final long pid = p.getPid();
          System.out.println("pid = " + pid);
        }
    );
```

But if you already know the PID, you can get the ProcessHandle for this as well with the method ```of(..)```

```java
    final ProcessHandle processOne = ProcessHandle.of(1).get();
```
From this you could get all child processes as a Stream.
```java
    processOne.children().forEach(p -> System.out.println("p = " + p.info() ));
```
Or you could get the father. 

```java
    ProcessHandle
        .current()
        .parent()
        .ifPresent(f -> out.println("f.getPid() = " + f.getPid()));
```
If you want to have a children plus sub-children of a process, you could use the method ```descendants()```

```java
    ProcessHandle
        .current()
        .descendants()
        .forEach(p -> out.println("p = " + p.info() ));
```
### ProcessHandle.Info
This class will hold a few informations together , like a status snapshot. 
All values are wrapped into an Optional. 

```java
      final ProcessHandle start = ProcessHandle.current();
      final ProcessHandle.Info info = start.info();

      info.commandLine().ifPresent(a -> out.println("commandLine = " + a));
      info.command().ifPresent(a -> out.println("command = " + a));
      info.arguments().ifPresent(a -> out.println("arguments = " + asList(a)));
      info.startInstant().ifPresent(t -> out.println("startInstant = " + ofInstant(t, systemDefault())));
      info.totalCpuDuration().ifPresent(d -> out.println("d [ms] = " + d.toMillis()));
      info.user().ifPresent(u -> out.println("user = " + u));
```

## java.lang.Process
The class Process itself is since JDK 1.0 available. But still it will be improved.
With Java9 we got a few more methods to play with.
A few of them are for information only, like ```public boolean supportsNormalTermination()```
or ```public long getPid()```. The methods ```public Stream<ProcessHandle> children()``` and 
```### public Stream<ProcessHandle> descendants()``` we know from the class ProcessHandle already.

To convert into a ProcessHandle we could use the method ```toHandle()``` and the delegator ```info()```
will give us the ProcessHandle.Info instance.

But there is a really nice new method available.

### public CompletableFuture<Process> onExit()

With the method ```onExit()```  we are able to create async tree´s of processes. 
An easy example you could find here [JEP102 - V006](http://bit.ly/JEP102V006) 

The basic idea behind ist the concatenation of CompletableFuture´s.
We will start with the definition of a Function that will transform a ```String``` into a 
```Supplier<ProcessBuilder>```
 
```java
  private static Function<String, Supplier<ProcessBuilder>> commandSupplierFunction
      = command -> () -> new ProcessBuilder()
      .command(command)
      .inheritIO()
      .redirectOutput(ProcessBuilder.Redirect.INHERIT)
      .redirectError(ProcessBuilder.Redirect.INHERIT);

```
With this we could define easily ```CompletableFuture<Optional<Process>>``` 
to describe commands we would like to start.

```java
        final CompletableFuture<Optional<Process>> commandJConsole = CompletableFuture
        .supplyAsync(commandSupplierFunction.apply("jconsole"))
        .handleAsync(JEP102V006.START_PROCESS);

    final CompletableFuture<Optional<Process>> commandJMC = CompletableFuture
        .supplyAsync(commandSupplierFunction.apply("jmc"))
        .handleAsync(JEP102V006.START_PROCESS);

```

Now we have to combine all processes together. Here in this example I want to start 
concurrently ***jconsole*** and ***Java Mission Control***. After I closed both processes 
I want to start ***jvisualvm***. 

```java
commandJConsole
        .thenCombineAsync(commandJMC, (jconsoleOpt, jmcOpt) -> {
          System.out.println("both proc. are started? " + jconsoleOpt.isPresent() + " - " + jmcOpt.isPresent());
          final CompletableFuture<Process> jconsoleProcess = jconsoleOpt.get().onExit();
          final CompletableFuture<Process> jmcProcess = jmcOpt.get().onExit();
          return jconsoleProcess
              .thenCombineAsync(jmcProcess, (jconsole, jmc) -> {
                //both are done -> work on result
                System.out.println("jconsole.getPid() = " + jconsole.getPid());
                System.out.println("jmc.getPid() = " + jmc.getPid());
                return CompletableFuture //-> create the next COMMAND_SUPPLIER_FUNCTION
                    .supplyAsync(commandSupplierFunction.apply("jvisualvm"));
              })
              .thenComposeAsync(cf -> cf); // flatMap
        })
        .thenComposeAsync(cf -> cf) // flatMap
        .handleAsync(JEP102V006.START_PROCESS)  // start third proc
        .join()
        .ifPresent(p -> p
            .onExit()
            .thenAccept(process -> System.out.println("process.getPid() = " + process.getPid()))
            .join()
        );
```

As you could see, the main task is not tooooooo difficult. 
But this is not nice, if you have to write this a few times.
This is a good point to start with a few refactorings.

Lets start with the way to start a process. This is generic and we could write it like the following.
```java
public static final BiFunction<ProcessBuilder, Throwable, Optional<Process>> START_PROCESS = (processBuilder, throwable) -> {
    try {
      System.out.println("startProcess = " + processBuilder.command());
      return Optional.of(processBuilder.start());
    } catch (IOException e) {
      e.printStackTrace();
      return Optional.empty();
    }
  };
```

For this we need a way to define and create a ```Supplier<ProcessBuilder>```

```java
  public static final Function<String, Supplier<ProcessBuilder>> COMMAND_SUPPLIER_FUNCTION
      = command -> () -> new ProcessBuilder()
      .command(command)
      .inheritIO()
      .redirectOutput(ProcessBuilder.Redirect.INHERIT)
      .redirectError(ProcessBuilder.Redirect.INHERIT);
```

Both together will start the command...

```java
  public static final Function<String, CompletableFuture<Optional<Process>>> CREATE_AND_START_PROCESS = command
      -> CompletableFuture
          .supplyAsync(COMMAND_SUPPLIER_FUNCTION.apply(command))
          .handleAsync(START_PROCESS);

``` 

Now we will get the little bit complex part. We want to join process-results and start a new one. 
The most of it is generic and could be extracted into a FunctionalInterface.

```java
  @FunctionalInterface
  public interface JoinProcesses extends BiFunction<CompletableFuture<Optional<Process>>,
                                                    CompletableFuture<Optional<Process>>,
                                                    CompletableFuture<Optional<Process>>> {

    BiFunction<CompletableFuture<Process>,
               CompletableFuture<Process>,
               BiFunction<Process,
                          Process,
                          Supplier<ProcessBuilder>>> processResultBiFunction();
    
    @Override
    default CompletableFuture<Optional<Process>> apply(CompletableFuture<Optional<Process>> procOptA,
                                                       CompletableFuture<Optional<Process>> procOptB) {
      // here more specific exception handlimg or default behavior
      // System.out.println("both proc. are started? " + procOptA.isPresent() + " - " + procOptB.isPresent());
      final CompletableFuture<Process> procA = procOptA.thenComposeAsync(p -> p.get().onExit());
      final CompletableFuture<Process> procB = procOptB.thenComposeAsync(p -> p.get().onExit());
      return procA
          .thenCombineAsync(procB, processResultBiFunction().apply(procA, procB))
          .handleAsync((processBuilderSupplier, throwable)
              -> JEP102V006.START_PROCESS.apply(processBuilderSupplier.get(), throwable));
    }
  }
```

The part that must be defined by the developer is the method ```processResultBiFunction()```. 
The task here will be to deal with the two
results from the processes and decide what would be the next one to start.

From the developer point of few we have to define two things now.
First one is, what are the processes to start and combine. 

```java
((JEP102V006.JoinProcesses) () -> processResults)
        .apply(JEP102V006.CREATE_AND_START_PROCESS.apply("jconsole"),
            JEP102V006.CREATE_AND_START_PROCESS.apply("jmc"))
        .join()
        .ifPresent(p -> p
            .onExit()
            .thenAccept(process -> System.out.println("process.getPid() = " + process.getPid()))
            .join()
        );
```
And second would be the dealing with the result of the 
processes and the decision what would be the next command.

```java

private static final BiFunction<CompletableFuture<Process>,
                                  CompletableFuture<Process>,
                                  BiFunction<Process,
                                             Process,
                                             Supplier<ProcessBuilder>>> processResults
      = (procCFA, procCFB) -> {
    final Process procA = procCFA.join();
    final Process procB = procCFB.join();
    System.out.println("jconsole.getPid() = " + procA.getPid());
    System.out.println("jmc.getPid() = " + procB.getPid());
    // work on result....
    return (process, process2) -> JEP102V006.COMMAND_SUPPLIER_FUNCTION.apply("jvisualvm");
  };
```

Now we are able to define a tree of external processes nearly fully async, based on ***CompletableFuture***
