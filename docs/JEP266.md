# More Concurrency Updates
This [JEP](http://openjdk.java.net/jeps/266) is flagged with **core-util.concurrent**.

## Publisher Subscriber

### One subscriber with consume

For the beginning just create one Publisher and consume all messages.
For the Publisher we use the `SubmissionPublisher` provided by the Java API so we do not have to implement the Interface. 
 The `SubmissionPublisher` implements `AutoClosable` so we can create it in a try with resources and do not have to bother closing it.
 
 With the method `public CompletableFuture<Void> consume(Consumer<? super T> consumer) `
 we can add a Consumer. The Consumer interface is a functional interface so we can easily use lamdas to implement it. In return we get a `CompletableFuture<Void>` which is done when the `Publisher` is closed. So we can wait for the completion with `get()` in the finally block of the try. So we can be sure that the work is done.
 
 Now we only need to add something to publish to the publisher. This is achieved with the `public int submit(T item)` method of the `SubmissionPublisher`.
 An example of this will look like this:

```java
public class JEP266v001 {
  public static void main(String[] args) throws InterruptedException, ExecutionException {
    CompletableFuture consume = null;
    try (SubmissionPublisher pup = new SubmissionPublisher<String>()) {
      consume = pup.consume(System.out::println);
      IntStream.range(1, 10).forEach(pup::submit);
    } finally {
      consume.get();
    }
  }
}

```

The output of this code looks like this:
```text
1
2
3
4
5
6
7
8
9

Process finished with exit code 0
```
So all messages where published and printed to stdout.

### Writing your own subscriber
To write your own subscriber you need to implement the interface ` public static interface Subscriber<T> ` in the class `Flow`. For this example lets write a Subscriber which greets the messages on stdout. The Greeter shall have a name so we can identify the subscriber if we add multiple instances to one publisher.
 
```java
  public static class GreetingSubscriber implements Flow.Subscriber<String> {

    private final String name;
    private Flow.Subscription subscription;

    public GreetingSubscriber(String name) {
      this.name = name;
    }

    @Override
    public void onSubscribe(Flow.Subscription subscription) {
      this.subscription = subscription;
      subscription.request(1);
    }


    @Override
    public void onNext(String item) {
      subscription.request(1);
      System.out.println(String.format("%s says: Hello %s", name, item));
      System.out.flush();
    }

    @Override
    public void onError(Throwable throwable) {
      System.err.print(throwable);
    }

    @Override
    public void onComplete() {
      // nothing to do here
    }
  }
```

The method `public void onSubscribe(Flow.Subscription subscription)` is called when a subscriber subscribes to a publisher. We will get a `Subscription` object which represents the connection with the publisher. When we subscribe we have to request a number of messages we want to process. This is done via the `public void request(long n)` method of the `Subscription`. For this example we will request only one message at a time so wi call: 
```java
subscription.request(1);
```
If we want to get an unbound amount of messages we would have to call: 
```java
subscription.request(Long.MAX_VALUE);
```


But because we only have requested one message we need to request additiional messages when we process a message. Therefor we store the `Subscription` in a member variable.

The the work is done in the `public void onNext(T item)` method. In this method we greet the message and request a new one.
```java
@Override
    public void onNext(String item) {
      subscription.request(1);
      System.out.println(String.format("%s says: Hello %s", name, item));
      System.out.flush();
    }
```

Now we have a working subscriber lets add it to a publisher.

```java
 public static void main(String[] args) throws InterruptedException {

    try (SubmissionPublisher pup = new SubmissionPublisher<String>()) {

      pup.subscribe(new GreetingSubscriber("Sub1"));

      IntStream.range(1, 10)
              .boxed()
              .map(String::valueOf)
              .forEach(pup::submit);

      System.out.println("published all the numbers");
      Thread.sleep(100 + pup.estimateMaximumLag());
    }
  }
```
We start like before and create a `SubmissionPublisher` in a try with resource.
Then we subscribe our subscriber to the publisher with  `pup.subscribe(new GreetingSubscriber("Sub1"));`. Then we add messages to the publisher. But this time we do not get  future to wait for. If we would run the code without a sleep we would only see that we published all numbers but potentially no greeting.
```text
published all the numbers

Process finished with exit code 0
```

To let the subscribers do work they need time. So lets put the main thread to sleep.
` Thread.sleep(100 + pup.estimateMaximumLag());`
The publisher can give us a estimation on how much lag there most likely will be. We add a little bit of extra time and now we should see the greetings.
```text
published all the numbers
Sub1 says: Hello 1
Sub1 says: Hello 2
Sub1 says: Hello 3
Sub1 says: Hello 4
Sub1 says: Hello 5
Sub1 says: Hello 6
Sub1 says: Hello 7
Sub1 says: Hello 8
Sub1 says: Hello 9

Process finished with exit code 0
```

### Adding a second subscriber
We can add a second subscriber to the same publisher.

```java
 public static void main(String[] args) throws InterruptedException {

    try (SubmissionPublisher pup = new SubmissionPublisher<String>()) {

      pup.subscribe(new GreetingSubscriber("Sub1"));
      pup.subscribe(new GreetingSubscriber("Sub2"));

      IntStream.range(1, 10)
              .boxed()
              .map(String::valueOf)
              .forEach(pup::submit);

      System.out.println("published all the numbers");
      Thread.sleep(100 + pup.estimateMaximumLag());
    }
  }
```
If we run this we see an output like this:
```text
published all the numbers
Sub1 says: Hello 1
Sub2 says: Hello 1
Sub2 says: Hello 2
Sub2 says: Hello 3
Sub2 says: Hello 4
Sub2 says: Hello 5
Sub2 says: Hello 6
Sub2 says: Hello 7
Sub2 says: Hello 8
Sub2 says: Hello 9
Sub1 says: Hello 2
Sub1 says: Hello 3
Sub1 says: Hello 4
Sub1 says: Hello 5
Sub1 says: Hello 6
Sub1 says: Hello 7
Sub1 says: Hello 8
Sub1 says: Hello 9

Process finished with exit code 0

```
Note that the subscribers are not handled in order.

### Adding a processor

A processor is a subscriber and a supplier in one class. It can be used to process messages e.g. convert them from one type to another.

To write a processor we extend the `SubmissionPublisher<TO>` with the type after the conversion and implement `Flow.Processor<FROM, TO>`  with `TO` being the same type as in the publisher and `FROM` being the type we receive. 

For this example if we want to convert an `Integer` to a `String` the class has to look something like this.

```java
 public static class IntToStringProcessor extends SubmissionPublisher<String> implements Flow.Processor<Integer, String>
```
Because we are a `Subscriber` we need to implement the method `onSubscribe`. We do this like we did in the subscribers before:

 ```java
    @Override
      public void onSubscribe(Flow.Subscription subscription) {
        this.subscription = subscription;
        this.subscription.request(1);
      }
 ```
 We store the subscription in a member and request one message.
 Then we need to implement the `onNext` method. 
 
```java
    @Override
    public void onNext(Integer item) {
      submit(String.valueOf(item));
      subscription.request(1);
    }
```
We recieve one Integer as message, convert it to a String and then submit the String. The `submit` method is provided by the `SubmissionPublisher` we extend.
After submitting the message our work is done and we request another message.
The whole class looks something like this:

```java
  public static class IntToStringProcessor extends SubmissionPublisher<String> implements Flow.Processor<Integer, String> {

    private Flow.Subscription subscription;

    @Override
    public void onSubscribe(Flow.Subscription subscription) {
      this.subscription = subscription;
      this.subscription.request(1);
    }

    @Override
    public void onNext(Integer item) {
      submit(String.valueOf(item));
      subscription.request(1);
    }

    @Override
    public void onError(Throwable throwable) {

    }

    @Override
    public void onComplete() {

    }
  }
```

Now we can bind our processor into our workflow. This is done by subscribing to the publisher. The subscriber on the other hand subscribes to the processor.

```java
 public static void main(String[] args) throws InterruptedException {

    try (SubmissionPublisher pup = new SubmissionPublisher<Integer>()) {

      IntToStringProcessor processor = new IntToStringProcessor();
      pup.subscribe(processor);
      processor.subscribe(new TestSubscriber("Sub1"));

      IntStream.range(1, 10)
              .forEach(pup::submit);

      System.out.println("published all the numbers");
      Thread.sleep(100 + pup.estimateMaximumLag());
    }
  }
```
This time we do not convert the `IntStream`, we let our processor do the work.
The output of this code looks like this:

```text
published all the numbers
Sub1 says: Hello 1
Sub1 says: Hello 2
Sub1 says: Hello 3
Sub1 says: Hello 4
Sub1 says: Hello 5
Sub1 says: Hello 6
Sub1 says: Hello 7
Sub1 says: Hello 8
Sub1 says: Hello 9

Process finished with exit code 0
```




## java.util.concurrent.CompletableFuture improvements in Java9



### public Executor defaultExecutor()
### public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier, Executor executor)
### public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier)

### public <U> CompletableFuture<U> newIncompleteFuture()
### public CompletionStage<T> minimalCompletionStage()
### public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)
### public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)
### public static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)
### public static Executor delayedExecutor(long delay, TimeUnit unit)
### public static <U> CompletionStage<U> completedStage(U value)
### public static <U> CompletableFuture<U> failedFuture(Throwable ex)
### public static <U> CompletionStage<U> failedStage(Throwable ex)
