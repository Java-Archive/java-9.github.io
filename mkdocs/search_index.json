{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to java-9.org\n\n\nHere I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.\n\n\nCorresponding to this website I am creating demo codes that are available under\n\n\ngithub - java-9 / workshop_java09", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-java-9org", 
            "text": "Here I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.  Corresponding to this website I am creating demo codes that are available under  github - java-9 / workshop_java09", 
            "title": "Welcome to java-9.org"
        }, 
        {
            "location": "/JEP102/", 
            "text": "Process API Updates\n\n\nThis \nJEP\n is flagged with \ncore-lang\n.\n\n\njava.lang.ProcessBuilder\n\n\npublic static final Redirect DISCARD\n\n\nIf you are using the ProcessBuilder, you could define where \nthe output will be redirected.\nNew here in Java 9 is \ndev/null\n ;-)\n\n\nFirst we are writing all to the stdout.\n\n\npublic static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    // only if installed\n    final ProcessBuilder command = processBuilder.command(\njava\n, \n-version\n); \n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n          .redirectError(ProcessBuilder.Redirect.INHERIT);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n\n  }\n\n\n\n\nIn this version you will see something like the following.\n\n\njava version \n1.8.0_112\n\nJava(TM) SE Runtime Environment (build 1.8.0_112-b16)\nJava HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)\n\n\n\n\nIf we are the new redirect we will see..... nothing...\n\n\npublic static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    final ProcessBuilder command = processBuilder.command(\njava\n, \n-version\n); // only if installed\n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.DISCARD)\n          .redirectError(ProcessBuilder.Redirect.DISCARD);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n\n\n\n\njava.lang.ProcessHandle\n\n\nWith this we got a possibility to manage the process easy and a \nway to get information's about the started process itself.\n\n\nFirst we will start to get some information's about the process itself we are running.\n\n\n    final ProcessHandle current = ProcessHandle.current();\n    final long pid = current.getPid();\n    System.out.println(\npid = \n + pid);\n\n\n\n\nHere we are asking for the PID of our own process. But we could get easily \na Stream of all running processes.\n\n\n    final Stream\nProcessHandle\n processHandleStream = ProcessHandle.allProcesses();\n\n    processHandleStream.forEach( p -\n {\n          final long pid = p.getPid();\n          System.out.println(\npid = \n + pid);\n        }\n    );\n\n\n\n\nBut if you already know the PID, you can get the ProcessHandle for this as well with the method \nof(..)\n\n\n    final ProcessHandle processOne = ProcessHandle.of(1).get();\n\n\n\n\nFrom this you could get all child processes as a Stream.\n\n\n    processOne.children().forEach(p -\n System.out.println(\np = \n + p.info() ));\n\n\n\n\nOr you could get the father. \n\n\n    ProcessHandle\n        .current()\n        .parent()\n        .ifPresent(f -\n out.println(\nf.getPid() = \n + f.getPid()));\n\n\n\n\nIf you want to have a children plus sub-children of a process, you could use the method \ndescendants()\n\n\n    ProcessHandle\n        .current()\n        .descendants()\n        .forEach(p -\n out.println(\np = \n + p.info() ));\n\n\n\n\nProcessHandle.Info\n\n\nThis class will hold a few informations together , like a status snapshot. \nAll values are wrapped into an Optional. \n\n\n      final ProcessHandle start = ProcessHandle.current();\n      final ProcessHandle.Info info = start.info();\n\n      info.commandLine().ifPresent(a -\n out.println(\ncommandLine = \n + a));\n      info.command().ifPresent(a -\n out.println(\ncommand = \n + a));\n      info.arguments().ifPresent(a -\n out.println(\narguments = \n + asList(a)));\n      info.startInstant().ifPresent(t -\n out.println(\nstartInstant = \n + ofInstant(t, systemDefault())));\n      info.totalCpuDuration().ifPresent(d -\n out.println(\nd [ms] = \n + d.toMillis()));\n      info.user().ifPresent(u -\n out.println(\nuser = \n + u));\n\n\n\n\njava.lang.Process\n\n\nThe class Process itself is since JDK 1.0 available. But still it will be improved.\nWith Java9 we got a few more methods to play with.\nA few of them are for information only, like \npublic boolean supportsNormalTermination()\n\nor \npublic long getPid()\n. The methods \npublic Stream\nProcessHandle\n children()\n and \n\n### public Stream\nProcessHandle\n descendants()\n we know from the class ProcessHandle already.\n\n\nTo convert into a ProcessHandle we could use the method \ntoHandle()\n and the delegator \ninfo()\n\nwill give us the ProcessHandle.Info instance.\n\n\nBut there is a really nice new method available.\n\n\npublic CompletableFuture\n onExit()\n\n\nWith the method \nonExit()\n  we are able to create async tree\u00b4s of processes. \nAn easy example you could find here \nJEP102 - V006\n \n\n\nThe basic idea behind ist the concatenation of CompletableFuture\u00b4s.\nWe will start with the definition of a Function that will transform a \nString\n into a \n\nSupplier\nProcessBuilder\n\n\n  private static Function\nString, Supplier\nProcessBuilder\n commandSupplierFunction\n      = command -\n () -\n new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);\n\n\n\n\n\nWith this we could define easily \nCompletableFuture\nOptional\nProcess\n \nto describe commands we would like to start.\n\n\n        final CompletableFuture\nOptional\nProcess\n commandJConsole = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply(\njconsole\n))\n        .handleAsync(JEP102V006.START_PROCESS);\n\n    final CompletableFuture\nOptional\nProcess\n commandJMC = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply(\njmc\n))\n        .handleAsync(JEP102V006.START_PROCESS);\n\n\n\n\n\nNow we have to combine all processes together. Here in this example I want to start \nconcurrently \njconsole\n and \nJava Mission Control\n. After I closed both processes \nI want to start \njvisualvm\n. \n\n\ncommandJConsole\n        .thenCombineAsync(commandJMC, (jconsoleOpt, jmcOpt) -\n {\n          System.out.println(\nboth proc. are started? \n + jconsoleOpt.isPresent() + \n - \n + jmcOpt.isPresent());\n          final CompletableFuture\nProcess\n jconsoleProcess = jconsoleOpt.get().onExit();\n          final CompletableFuture\nProcess\n jmcProcess = jmcOpt.get().onExit();\n          return jconsoleProcess\n              .thenCombineAsync(jmcProcess, (jconsole, jmc) -\n {\n                //both are done -\n work on result\n                System.out.println(\njconsole.getPid() = \n + jconsole.getPid());\n                System.out.println(\njmc.getPid() = \n + jmc.getPid());\n                return CompletableFuture //-\n create the next COMMAND_SUPPLIER_FUNCTION\n                    .supplyAsync(commandSupplierFunction.apply(\njvisualvm\n));\n              })\n              .thenComposeAsync(cf -\n cf); // flatMap\n        })\n        .thenComposeAsync(cf -\n cf) // flatMap\n        .handleAsync(JEP102V006.START_PROCESS)  // start third proc\n        .join()\n        .ifPresent(p -\n p\n            .onExit()\n            .thenAccept(process -\n System.out.println(\nprocess.getPid() = \n + process.getPid()))\n            .join()\n        );\n\n\n\n\nAs you could see, the main task is not tooooooo difficult. \nBut this is not nice, if you have to write this a few times.\nThis is a good point to start with a few refactorings.\n\n\nLets start with the way to start a process. This is generic and we could write it like the following.\n\n\npublic static final BiFunction\nProcessBuilder, Throwable, Optional\nProcess\n START_PROCESS = (processBuilder, throwable) -\n {\n    try {\n      System.out.println(\nstartProcess = \n + processBuilder.command());\n      return Optional.of(processBuilder.start());\n    } catch (IOException e) {\n      e.printStackTrace();\n      return Optional.empty();\n    }\n  };\n\n\n\n\nFor this we need a way to define and create a \nSupplier\nProcessBuilder\n\n\n  public static final Function\nString, Supplier\nProcessBuilder\n COMMAND_SUPPLIER_FUNCTION\n      = command -\n () -\n new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);\n\n\n\n\nBoth together will start the command...\n\n\n  public static final Function\nString, CompletableFuture\nOptional\nProcess\n CREATE_AND_START_PROCESS = command\n      -\n CompletableFuture\n          .supplyAsync(COMMAND_SUPPLIER_FUNCTION.apply(command))\n          .handleAsync(START_PROCESS);\n\n\n\n\n\nNow we will get the little bit complex part. We want to join process-results and start a new one. \nThe most of it is generic and could be extracted into a FunctionalInterface.\n\n\n  @FunctionalInterface\n  public interface JoinProcesses extends BiFunction\nCompletableFuture\nOptional\nProcess\n,\n                                                    CompletableFuture\nOptional\nProcess\n,\n                                                    CompletableFuture\nOptional\nProcess\n {\n\n    BiFunction\nCompletableFuture\nProcess\n,\n               CompletableFuture\nProcess\n,\n               BiFunction\nProcess,\n                          Process,\n                          Supplier\nProcessBuilder\n processResultBiFunction();\n\n    @Override\n    default CompletableFuture\nOptional\nProcess\n apply(CompletableFuture\nOptional\nProcess\n procOptA,\n                                                       CompletableFuture\nOptional\nProcess\n procOptB) {\n      // here more specific exception handlimg or default behavior\n      // System.out.println(\nboth proc. are started? \n + procOptA.isPresent() + \n - \n + procOptB.isPresent());\n      final CompletableFuture\nProcess\n procA = procOptA.thenComposeAsync(p -\n p.get().onExit());\n      final CompletableFuture\nProcess\n procB = procOptB.thenComposeAsync(p -\n p.get().onExit());\n      return procA\n          .thenCombineAsync(procB, processResultBiFunction().apply(procA, procB))\n          .handleAsync((processBuilderSupplier, throwable)\n              -\n JEP102V006.START_PROCESS.apply(processBuilderSupplier.get(), throwable));\n    }\n  }\n\n\n\n\nThe part that must be defined by the developer is the method \nprocessResultBiFunction()\n. \nThe task here will be to deal with the two\nresults from the processes and decide what would be the next one to start.\n\n\nFrom the developer point of few we have to define two things now.\nFirst one is, what are the processes to start and combine. \n\n\n((JEP102V006.JoinProcesses) () -\n processResults)\n        .apply(JEP102V006.CREATE_AND_START_PROCESS.apply(\njconsole\n),\n            JEP102V006.CREATE_AND_START_PROCESS.apply(\njmc\n))\n        .join()\n        .ifPresent(p -\n p\n            .onExit()\n            .thenAccept(process -\n System.out.println(\nprocess.getPid() = \n + process.getPid()))\n            .join()\n        );\n\n\n\n\nAnd second would be the dealing with the result of the \nprocesses and the decision what would be the next command.\n\n\n\nprivate static final BiFunction\nCompletableFuture\nProcess\n,\n                                  CompletableFuture\nProcess\n,\n                                  BiFunction\nProcess,\n                                             Process,\n                                             Supplier\nProcessBuilder\n processResults\n      = (procCFA, procCFB) -\n {\n    final Process procA = procCFA.join();\n    final Process procB = procCFB.join();\n    System.out.println(\njconsole.getPid() = \n + procA.getPid());\n    System.out.println(\njmc.getPid() = \n + procB.getPid());\n    // work on result....\n    return (process, process2) -\n JEP102V006.COMMAND_SUPPLIER_FUNCTION.apply(\njvisualvm\n);\n  };\n\n\n\n\nNow we are able to define a tree of external processes nearly fully async, based on \nCompletableFuture", 
            "title": "JEP102"
        }, 
        {
            "location": "/JEP102/#process-api-updates", 
            "text": "This  JEP  is flagged with  core-lang .", 
            "title": "Process API Updates"
        }, 
        {
            "location": "/JEP102/#javalangprocessbuilder", 
            "text": "public static final Redirect DISCARD  If you are using the ProcessBuilder, you could define where \nthe output will be redirected.\nNew here in Java 9 is  dev/null  ;-)  First we are writing all to the stdout.  public static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    // only if installed\n    final ProcessBuilder command = processBuilder.command( java ,  -version ); \n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n          .redirectError(ProcessBuilder.Redirect.INHERIT);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n\n  }  In this version you will see something like the following.  java version  1.8.0_112 \nJava(TM) SE Runtime Environment (build 1.8.0_112-b16)\nJava HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)  If we are the new redirect we will see..... nothing...  public static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    final ProcessBuilder command = processBuilder.command( java ,  -version ); // only if installed\n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.DISCARD)\n          .redirectError(ProcessBuilder.Redirect.DISCARD);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n  }", 
            "title": "java.lang.ProcessBuilder"
        }, 
        {
            "location": "/JEP102/#javalangprocesshandle", 
            "text": "With this we got a possibility to manage the process easy and a \nway to get information's about the started process itself.  First we will start to get some information's about the process itself we are running.      final ProcessHandle current = ProcessHandle.current();\n    final long pid = current.getPid();\n    System.out.println( pid =   + pid);  Here we are asking for the PID of our own process. But we could get easily \na Stream of all running processes.      final Stream ProcessHandle  processHandleStream = ProcessHandle.allProcesses();\n\n    processHandleStream.forEach( p -  {\n          final long pid = p.getPid();\n          System.out.println( pid =   + pid);\n        }\n    );  But if you already know the PID, you can get the ProcessHandle for this as well with the method  of(..)      final ProcessHandle processOne = ProcessHandle.of(1).get();  From this you could get all child processes as a Stream.      processOne.children().forEach(p -  System.out.println( p =   + p.info() ));  Or you could get the father.       ProcessHandle\n        .current()\n        .parent()\n        .ifPresent(f -  out.println( f.getPid() =   + f.getPid()));  If you want to have a children plus sub-children of a process, you could use the method  descendants()      ProcessHandle\n        .current()\n        .descendants()\n        .forEach(p -  out.println( p =   + p.info() ));  ProcessHandle.Info  This class will hold a few informations together , like a status snapshot. \nAll values are wrapped into an Optional.         final ProcessHandle start = ProcessHandle.current();\n      final ProcessHandle.Info info = start.info();\n\n      info.commandLine().ifPresent(a -  out.println( commandLine =   + a));\n      info.command().ifPresent(a -  out.println( command =   + a));\n      info.arguments().ifPresent(a -  out.println( arguments =   + asList(a)));\n      info.startInstant().ifPresent(t -  out.println( startInstant =   + ofInstant(t, systemDefault())));\n      info.totalCpuDuration().ifPresent(d -  out.println( d [ms] =   + d.toMillis()));\n      info.user().ifPresent(u -  out.println( user =   + u));", 
            "title": "java.lang.ProcessHandle"
        }, 
        {
            "location": "/JEP102/#javalangprocess", 
            "text": "The class Process itself is since JDK 1.0 available. But still it will be improved.\nWith Java9 we got a few more methods to play with.\nA few of them are for information only, like  public boolean supportsNormalTermination() \nor  public long getPid() . The methods  public Stream ProcessHandle  children()  and  ### public Stream ProcessHandle  descendants()  we know from the class ProcessHandle already.  To convert into a ProcessHandle we could use the method  toHandle()  and the delegator  info() \nwill give us the ProcessHandle.Info instance.  But there is a really nice new method available.  public CompletableFuture  onExit()  With the method  onExit()   we are able to create async tree\u00b4s of processes. \nAn easy example you could find here  JEP102 - V006    The basic idea behind ist the concatenation of CompletableFuture\u00b4s.\nWe will start with the definition of a Function that will transform a  String  into a  Supplier ProcessBuilder    private static Function String, Supplier ProcessBuilder  commandSupplierFunction\n      = command -  () -  new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);  With this we could define easily  CompletableFuture Optional Process  \nto describe commands we would like to start.          final CompletableFuture Optional Process  commandJConsole = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply( jconsole ))\n        .handleAsync(JEP102V006.START_PROCESS);\n\n    final CompletableFuture Optional Process  commandJMC = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply( jmc ))\n        .handleAsync(JEP102V006.START_PROCESS);  Now we have to combine all processes together. Here in this example I want to start \nconcurrently  jconsole  and  Java Mission Control . After I closed both processes \nI want to start  jvisualvm .   commandJConsole\n        .thenCombineAsync(commandJMC, (jconsoleOpt, jmcOpt) -  {\n          System.out.println( both proc. are started?   + jconsoleOpt.isPresent() +   -   + jmcOpt.isPresent());\n          final CompletableFuture Process  jconsoleProcess = jconsoleOpt.get().onExit();\n          final CompletableFuture Process  jmcProcess = jmcOpt.get().onExit();\n          return jconsoleProcess\n              .thenCombineAsync(jmcProcess, (jconsole, jmc) -  {\n                //both are done -  work on result\n                System.out.println( jconsole.getPid() =   + jconsole.getPid());\n                System.out.println( jmc.getPid() =   + jmc.getPid());\n                return CompletableFuture //-  create the next COMMAND_SUPPLIER_FUNCTION\n                    .supplyAsync(commandSupplierFunction.apply( jvisualvm ));\n              })\n              .thenComposeAsync(cf -  cf); // flatMap\n        })\n        .thenComposeAsync(cf -  cf) // flatMap\n        .handleAsync(JEP102V006.START_PROCESS)  // start third proc\n        .join()\n        .ifPresent(p -  p\n            .onExit()\n            .thenAccept(process -  System.out.println( process.getPid() =   + process.getPid()))\n            .join()\n        );  As you could see, the main task is not tooooooo difficult. \nBut this is not nice, if you have to write this a few times.\nThis is a good point to start with a few refactorings.  Lets start with the way to start a process. This is generic and we could write it like the following.  public static final BiFunction ProcessBuilder, Throwable, Optional Process  START_PROCESS = (processBuilder, throwable) -  {\n    try {\n      System.out.println( startProcess =   + processBuilder.command());\n      return Optional.of(processBuilder.start());\n    } catch (IOException e) {\n      e.printStackTrace();\n      return Optional.empty();\n    }\n  };  For this we need a way to define and create a  Supplier ProcessBuilder    public static final Function String, Supplier ProcessBuilder  COMMAND_SUPPLIER_FUNCTION\n      = command -  () -  new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);  Both together will start the command...    public static final Function String, CompletableFuture Optional Process  CREATE_AND_START_PROCESS = command\n      -  CompletableFuture\n          .supplyAsync(COMMAND_SUPPLIER_FUNCTION.apply(command))\n          .handleAsync(START_PROCESS);  Now we will get the little bit complex part. We want to join process-results and start a new one. \nThe most of it is generic and could be extracted into a FunctionalInterface.    @FunctionalInterface\n  public interface JoinProcesses extends BiFunction CompletableFuture Optional Process ,\n                                                    CompletableFuture Optional Process ,\n                                                    CompletableFuture Optional Process  {\n\n    BiFunction CompletableFuture Process ,\n               CompletableFuture Process ,\n               BiFunction Process,\n                          Process,\n                          Supplier ProcessBuilder  processResultBiFunction();\n\n    @Override\n    default CompletableFuture Optional Process  apply(CompletableFuture Optional Process  procOptA,\n                                                       CompletableFuture Optional Process  procOptB) {\n      // here more specific exception handlimg or default behavior\n      // System.out.println( both proc. are started?   + procOptA.isPresent() +   -   + procOptB.isPresent());\n      final CompletableFuture Process  procA = procOptA.thenComposeAsync(p -  p.get().onExit());\n      final CompletableFuture Process  procB = procOptB.thenComposeAsync(p -  p.get().onExit());\n      return procA\n          .thenCombineAsync(procB, processResultBiFunction().apply(procA, procB))\n          .handleAsync((processBuilderSupplier, throwable)\n              -  JEP102V006.START_PROCESS.apply(processBuilderSupplier.get(), throwable));\n    }\n  }  The part that must be defined by the developer is the method  processResultBiFunction() . \nThe task here will be to deal with the two\nresults from the processes and decide what would be the next one to start.  From the developer point of few we have to define two things now.\nFirst one is, what are the processes to start and combine.   ((JEP102V006.JoinProcesses) () -  processResults)\n        .apply(JEP102V006.CREATE_AND_START_PROCESS.apply( jconsole ),\n            JEP102V006.CREATE_AND_START_PROCESS.apply( jmc ))\n        .join()\n        .ifPresent(p -  p\n            .onExit()\n            .thenAccept(process -  System.out.println( process.getPid() =   + process.getPid()))\n            .join()\n        );  And second would be the dealing with the result of the \nprocesses and the decision what would be the next command.  \nprivate static final BiFunction CompletableFuture Process ,\n                                  CompletableFuture Process ,\n                                  BiFunction Process,\n                                             Process,\n                                             Supplier ProcessBuilder  processResults\n      = (procCFA, procCFB) -  {\n    final Process procA = procCFA.join();\n    final Process procB = procCFB.join();\n    System.out.println( jconsole.getPid() =   + procA.getPid());\n    System.out.println( jmc.getPid() =   + procB.getPid());\n    // work on result....\n    return (process, process2) -  JEP102V006.COMMAND_SUPPLIER_FUNCTION.apply( jvisualvm );\n  };  Now we are able to define a tree of external processes nearly fully async, based on  CompletableFuture", 
            "title": "java.lang.Process"
        }, 
        {
            "location": "/JEP110/", 
            "text": "HTTP/2 Client\n\n\nThis \nJEP\n is flagged with \ncore-net\n.", 
            "title": "JEP110"
        }, 
        {
            "location": "/JEP110/#http2-client", 
            "text": "This  JEP  is flagged with  core-net .", 
            "title": "HTTP/2 Client"
        }, 
        {
            "location": "/JEP259/", 
            "text": "Stack-Walking API\n\n\nThis \nJEP\n is flagged wit \ncore\n.\n\n\nAll source codes I am using here you could find under \n\n\ngithub - java-9 / workshop_java09\n\n\nStackWalker\n\n\nThe StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few \ngetIntance(..)\n methods.\n\n\nFor this examples I created a class \nHolder\n to create a Stack you could walk through.\n\n\n public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println(\nend reached..\n);\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }\n\n\n\n\nWith this we are creating a well defined stack now.\n\n\n    new Holder(new Holder(new Holder(null) )).doWork();\n\n\n\n\nThe output here will be something like the following. Have in mind that I was starting this from inside IntelliJ\n\n\nend reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n\n\n\n\nmore detailed informations\n\n\nYou could get more informations out of the StackWalker as you saw before.\nFor this the class Holder will be extended now a little bit more.\n\n\n public static class Holder002 {\n    private Holder002 holder;\n\n    public Holder002(final Holder002 holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println(\nend reached..\n);\n        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n            .forEach(stackFrame -\n {\n              final int byteCodeIndex = stackFrame.getByteCodeIndex();\n              System.out.println(\nbyteCodeIndex = \n + byteCodeIndex);\n              // byteCode Index :\n              final String className = stackFrame.getClassName();\n              System.out.println(\nclassName = \n + className);\n              final Class\n?\n declaringClass = stackFrame.getDeclaringClass();\n              System.out.println(\ndeclaringClass = \n + declaringClass);\n              final String fileName = stackFrame.getFileName();\n              System.out.println(\nfileName = \n + fileName);\n              final int lineNumber = stackFrame.getLineNumber();\n              System.out.println(\nlineNumber = \n + lineNumber);\n              final String methodName = stackFrame.getMethodName();\n              System.out.println(\nmethodName = \n + methodName);\n            });\n      } else {\n        holder.doWork();\n      }\n    }\n  }\n\n\n\n\nHere we have to use the first time a defined \ngetInstance(..)\n method to get all informations. \nIf you are not using the right \nStackWalker.Option\n the result will be an exception.\nYou have three Options.\n\n\n\n\n\n\nRETAIN_CLASS_REFERENCE:\n getCallerClass() and getDeclaringClass() will work\n\n\n\n\n\n\nSHOW_REFLECT_FRAMES:\n This will show all reflections frames that are hidden by default\n\n\n\n\n\n\nSHOW_HIDDEN_FRAMES:\n This will show all reflection frames and additionally implementation specific internal frames\n\n\n\n\n\n\nTwo things are not used in this example.\nFirst is the method \nisNativeMethod()\n to identify if the caller method in the stack is a JVM native one \nand second \ntoStackTraceElement()\n to convert this information to a StackTraceElement that you \ncould use to generate a more detailed Exception-Message. \n\n\nSystem.out.println(\nend reached..\n);\n        final StackTraceElement[] stackTraceElements = StackWalker\n            .getInstance()\n            .walk(sfStream -\n sfStream\n                .takeWhile(frame -\n frame.getClassName().startsWith(\norg.rapidpm\n))\n                .collect(Collectors.toList()))\n            .stream()\n            .map(StackWalker.StackFrame::toStackTraceElement)\n            .toArray(StackTraceElement[]::new);\n\n        try {\n          final RuntimeException runtimeException = new RuntimeException();\n          runtimeException.setStackTrace(stackTraceElements);\n          throw runtimeException;\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n\n\n\n\nThe output on my machine was.\n\n\nend reached..\njava.lang.RuntimeException\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:41)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004.main(JEP259V004.java:26)\n\n\n\n\nfilter the stack\n\n\nSometime you will have to filter a few of this information out that is given by the StackWalker.\nFor this you can work with the stream as done before at other places. The method \nwalk(..)\n will \ngive you the possibility to add a Predicate that will be used to filter the result.\nHere I only want to have all elements from a specific namespace. \n(btw: the method ``takeWhile()```  is new too, check for this the section about Streams)\n\n\nStackWalker\n            .getInstance()\n            .walk(sfStream -\n sfStream\n                .takeWhile(frame -\n frame.getClassName().startsWith(\norg.rapidpm\n))\n                .collect(Collectors.toList()))\n            .forEach(System.out::println);\n\n\n\n\nsometimes you only want to know...\n\n\nYes, sometimes you only want to know the caller class. Don\u00b4t worry, there is a simple solution.\n\n\nfinal Class\n?\n callerClass = StackWalker\n        .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) //Option needed\n        .getCallerClass();\n    System.out.println(\ncallerClass = \n + callerClass);", 
            "title": "JEP259"
        }, 
        {
            "location": "/JEP259/#stack-walking-api", 
            "text": "This  JEP  is flagged wit  core .  All source codes I am using here you could find under   github - java-9 / workshop_java09", 
            "title": "Stack-Walking API"
        }, 
        {
            "location": "/JEP259/#stackwalker", 
            "text": "The StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few  getIntance(..)  methods.  For this examples I created a class  Holder  to create a Stack you could walk through.   public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println( end reached.. );\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }  With this we are creating a well defined stack now.      new Holder(new Holder(new Holder(null) )).doWork();  The output here will be something like the following. Have in mind that I was starting this from inside IntelliJ  end reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)  more detailed informations  You could get more informations out of the StackWalker as you saw before.\nFor this the class Holder will be extended now a little bit more.   public static class Holder002 {\n    private Holder002 holder;\n\n    public Holder002(final Holder002 holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println( end reached.. );\n        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n            .forEach(stackFrame -  {\n              final int byteCodeIndex = stackFrame.getByteCodeIndex();\n              System.out.println( byteCodeIndex =   + byteCodeIndex);\n              // byteCode Index :\n              final String className = stackFrame.getClassName();\n              System.out.println( className =   + className);\n              final Class ?  declaringClass = stackFrame.getDeclaringClass();\n              System.out.println( declaringClass =   + declaringClass);\n              final String fileName = stackFrame.getFileName();\n              System.out.println( fileName =   + fileName);\n              final int lineNumber = stackFrame.getLineNumber();\n              System.out.println( lineNumber =   + lineNumber);\n              final String methodName = stackFrame.getMethodName();\n              System.out.println( methodName =   + methodName);\n            });\n      } else {\n        holder.doWork();\n      }\n    }\n  }  Here we have to use the first time a defined  getInstance(..)  method to get all informations. \nIf you are not using the right  StackWalker.Option  the result will be an exception.\nYou have three Options.    RETAIN_CLASS_REFERENCE:  getCallerClass() and getDeclaringClass() will work    SHOW_REFLECT_FRAMES:  This will show all reflections frames that are hidden by default    SHOW_HIDDEN_FRAMES:  This will show all reflection frames and additionally implementation specific internal frames    Two things are not used in this example.\nFirst is the method  isNativeMethod()  to identify if the caller method in the stack is a JVM native one \nand second  toStackTraceElement()  to convert this information to a StackTraceElement that you \ncould use to generate a more detailed Exception-Message.   System.out.println( end reached.. );\n        final StackTraceElement[] stackTraceElements = StackWalker\n            .getInstance()\n            .walk(sfStream -  sfStream\n                .takeWhile(frame -  frame.getClassName().startsWith( org.rapidpm ))\n                .collect(Collectors.toList()))\n            .stream()\n            .map(StackWalker.StackFrame::toStackTraceElement)\n            .toArray(StackTraceElement[]::new);\n\n        try {\n          final RuntimeException runtimeException = new RuntimeException();\n          runtimeException.setStackTrace(stackTraceElements);\n          throw runtimeException;\n        } catch (Exception e) {\n          e.printStackTrace();\n        }  The output on my machine was.  end reached..\njava.lang.RuntimeException\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:41)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004.main(JEP259V004.java:26)  filter the stack  Sometime you will have to filter a few of this information out that is given by the StackWalker.\nFor this you can work with the stream as done before at other places. The method  walk(..)  will \ngive you the possibility to add a Predicate that will be used to filter the result.\nHere I only want to have all elements from a specific namespace. \n(btw: the method ``takeWhile()```  is new too, check for this the section about Streams)  StackWalker\n            .getInstance()\n            .walk(sfStream -  sfStream\n                .takeWhile(frame -  frame.getClassName().startsWith( org.rapidpm ))\n                .collect(Collectors.toList()))\n            .forEach(System.out::println);  sometimes you only want to know...  Yes, sometimes you only want to know the caller class. Don\u00b4t worry, there is a simple solution.  final Class ?  callerClass = StackWalker\n        .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) //Option needed\n        .getCallerClass();\n    System.out.println( callerClass =   + callerClass);", 
            "title": "StackWalker"
        }, 
        {
            "location": "/JEP264/", 
            "text": "Platform Logging API and Service - LoggerFinder\n\n\nThis \nJEP\n is flagged with \ncore-util.logging\n.\n\n\nThe main thing of this JEP is providing a facade for logging. It is something like\nsl4j but now as part of the JDK.\n\n\nNow we have to give an answer to a few questions.\n\n\nHow to define a Logger?\n\n\nTo define a Logger by yourself, you could implement the interface \nSystem.Logger\n.\nWith this you could implement a Debugging-Logger for you project or delegate to the Implementation you want to use\nif there is nothing provided from the Logger-Framework itself.\n\n\npublic class SysOutLogger implements System.Logger {\n\n   @Override\n   public String getName() {\n     return SysOutLogger.class.getSimpleName();\n   }\n\n   @Override // this conf is useless ;-)\n   public boolean isLoggable(Level level) {\n     switch (level) {\n       case OFF: return false; \n       case TRACE: return false;\n       case DEBUG: return true;\n       case INFO: return true;\n       case WARNING: return false;\n       case ERROR: return false;\n       case ALL: return false;\n       default:\n         return true;\n     }\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n     System.out.printf(\nSysOutLogger: %s: \\\n%s\\\n with \\\n%s\\\n%n\n, level, msg, thrown);\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n     System.out.printf(\nSysOutLogger: %s: \\\n%s\\\n%n\n, level, format(format, params));\n   }\n }\n\n\n\n\nHow to declare this Logger so that it could be used?\n\n\nAfter this we have to make sure the system will use this one.\nFor this you have to extend the class \nSystem.LoggerFinder\n.\nHere you have to decide what will be the right Logger instance. This could be different in \nin different situations. You could use this for a more dynamic \nbehavior.\n\n\npublic class SysOutLoggerFinder extends System.LoggerFinder {\n\n  @Override\n  public System.Logger getLogger(String name, Module module) {\n    return new SysOutLogger();\n  }\n}\n\n\n\n\nSo far, so good..  but if you will try using it..  Nothing will happen.\nYou have to declare this as the active LoggingFinder.\nThe traditional way of doing it, would be a ServiceLocator. But with Java9 you could use\nthe file \nmodule-info.java\n\n\nmodule org.rapidpm.workshop.java09.jep264.v001.logger {\n  provides `\n      with org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder;\n}\n\n\n\n\nHere you could see, that the interface \njava.lang.System.LoggerFinder\n\nwill be connected with the implementation \norg.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder\n\n\nNow you could use it.\n\n\n    final System.Logger logger = System.getLogger(\nLoggerName\n);\n    System.out.println(logger.getName());\n    System.out.println(\nlogger = \n + logger);\n\n    final boolean loggable = logger.isLoggable(System.Logger.Level.DEBUG);\n    System.out.println(\nloggable = \n + loggable);\n\n    logger.log(System.Logger.Level.DEBUG, () -\n \nlogmessage\n);\n\n\n\n\n\nThe output would be something like the follwoing.\n\n\nSysOutLogger\nlogger = org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLogger@394e1a0f\nloggable = true\nSysOutLogger: x DEBUG: \nlogmessage\n\n\n\n\n\nHappy logging......", 
            "title": "JEP264"
        }, 
        {
            "location": "/JEP264/#platform-logging-api-and-service-loggerfinder", 
            "text": "This  JEP  is flagged with  core-util.logging .  The main thing of this JEP is providing a facade for logging. It is something like\nsl4j but now as part of the JDK.  Now we have to give an answer to a few questions.", 
            "title": "Platform Logging API and Service - LoggerFinder"
        }, 
        {
            "location": "/JEP264/#how-to-define-a-logger", 
            "text": "To define a Logger by yourself, you could implement the interface  System.Logger .\nWith this you could implement a Debugging-Logger for you project or delegate to the Implementation you want to use\nif there is nothing provided from the Logger-Framework itself.  public class SysOutLogger implements System.Logger {\n\n   @Override\n   public String getName() {\n     return SysOutLogger.class.getSimpleName();\n   }\n\n   @Override // this conf is useless ;-)\n   public boolean isLoggable(Level level) {\n     switch (level) {\n       case OFF: return false; \n       case TRACE: return false;\n       case DEBUG: return true;\n       case INFO: return true;\n       case WARNING: return false;\n       case ERROR: return false;\n       case ALL: return false;\n       default:\n         return true;\n     }\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n     System.out.printf( SysOutLogger: %s: \\ %s\\  with \\ %s\\ %n , level, msg, thrown);\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n     System.out.printf( SysOutLogger: %s: \\ %s\\ %n , level, format(format, params));\n   }\n }", 
            "title": "How to define a Logger?"
        }, 
        {
            "location": "/JEP264/#how-to-declare-this-logger-so-that-it-could-be-used", 
            "text": "After this we have to make sure the system will use this one.\nFor this you have to extend the class  System.LoggerFinder .\nHere you have to decide what will be the right Logger instance. This could be different in \nin different situations. You could use this for a more dynamic \nbehavior.  public class SysOutLoggerFinder extends System.LoggerFinder {\n\n  @Override\n  public System.Logger getLogger(String name, Module module) {\n    return new SysOutLogger();\n  }\n}  So far, so good..  but if you will try using it..  Nothing will happen.\nYou have to declare this as the active LoggingFinder.\nThe traditional way of doing it, would be a ServiceLocator. But with Java9 you could use\nthe file  module-info.java  module org.rapidpm.workshop.java09.jep264.v001.logger {\n  provides `\n      with org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder;\n}  Here you could see, that the interface  java.lang.System.LoggerFinder \nwill be connected with the implementation  org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder  Now you could use it.      final System.Logger logger = System.getLogger( LoggerName );\n    System.out.println(logger.getName());\n    System.out.println( logger =   + logger);\n\n    final boolean loggable = logger.isLoggable(System.Logger.Level.DEBUG);\n    System.out.println( loggable =   + loggable);\n\n    logger.log(System.Logger.Level.DEBUG, () -   logmessage );  The output would be something like the follwoing.  SysOutLogger\nlogger = org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLogger@394e1a0f\nloggable = true\nSysOutLogger: x DEBUG:  logmessage   Happy logging......", 
            "title": "How to declare this Logger so that it could be used?"
        }, 
        {
            "location": "/JEP266/", 
            "text": "More Concurrency Updates\n\n\nThis \nJEP\n is flagged with \ncore-util.concurrent\n.\n\n\nPublisher Subscriber\n\n\njava.util.concurrent.CompletableFuture improvements in Java9\n\n\npublic Executor defaultExecutor()\n\n\npublic CompletableFuture\n completeAsync(Supplier\n? extends T\n supplier, Executor executor)\n\n\npublic CompletableFuture\n completeAsync(Supplier\n? extends T\n supplier)\n\n\npublic \n CompletableFuture\n newIncompleteFuture()\n\n\npublic CompletionStage\n minimalCompletionStage()\n\n\npublic CompletableFuture\n orTimeout(long timeout, TimeUnit unit)\n\n\npublic CompletableFuture\n completeOnTimeout(T value, long timeout, TimeUnit unit)\n\n\npublic static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)\n\n\npublic static Executor delayedExecutor(long delay, TimeUnit unit)\n\n\npublic static \n CompletionStage\n completedStage(U value)\n\n\npublic static \n CompletableFuture\n failedFuture(Throwable ex)\n\n\npublic static \n CompletionStage\n failedStage(Throwable ex)", 
            "title": "JEP266"
        }, 
        {
            "location": "/JEP266/#more-concurrency-updates", 
            "text": "This  JEP  is flagged with  core-util.concurrent .", 
            "title": "More Concurrency Updates"
        }, 
        {
            "location": "/JEP266/#publisher-subscriber", 
            "text": "", 
            "title": "Publisher Subscriber"
        }, 
        {
            "location": "/JEP266/#javautilconcurrentcompletablefuture-improvements-in-java9", 
            "text": "public Executor defaultExecutor()  public CompletableFuture  completeAsync(Supplier ? extends T  supplier, Executor executor)  public CompletableFuture  completeAsync(Supplier ? extends T  supplier)  public   CompletableFuture  newIncompleteFuture()  public CompletionStage  minimalCompletionStage()  public CompletableFuture  orTimeout(long timeout, TimeUnit unit)  public CompletableFuture  completeOnTimeout(T value, long timeout, TimeUnit unit)  public static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)  public static Executor delayedExecutor(long delay, TimeUnit unit)  public static   CompletionStage  completedStage(U value)  public static   CompletableFuture  failedFuture(Throwable ex)  public static   CompletionStage  failedStage(Throwable ex)", 
            "title": "java.util.concurrent.CompletableFuture improvements in Java9"
        }, 
        {
            "location": "/java.lang/StackTraceElement/", 
            "text": "New Methods in java.lang.StackTraceElement\n\n\nThe class itself is inside the JDK since 1.4.\n\n\nThe StackTraceElement will now have the information about the module and module-version.\nFor this they added a new constructor \n\n\npublic StackTraceElement(String moduleName, \n                         String moduleVersion,\n                         String declaringClass, \n                         String methodName,String \n                         fileName, int lineNumber)\n\n\n\n\nand the new getter methods \npublic String getModuleName()\n and \npublic String getModuleVersion()\n\n\nIf you want to try this, play with the following.\n\n\npublic static void main(String[] args) {\n    try {\n      throw new RuntimeException(\nand go\n);\n    } catch (Exception e) {\n      final StackTraceElement[] stackTrace = e.getStackTrace();\n      for (StackTraceElement stackTraceElement : stackTrace) {\n        final String moduleName = stackTraceElement.getModuleName();\n        final String moduleVersion = stackTraceElement.getModuleVersion();\n        System.out.println(\nmoduleVersion = \n + moduleVersion);\n        System.out.println(\nmoduleName = \n + moduleName);\n        System.out.println(stackTraceElement.getClassName() + \n - \n + stackTraceElement.getMethodName());\n      }\n    }\n  }\n\n\n\n\nThe output at may machine was the following.\n\n\nmoduleVersion = null\nmoduleName = null\norg.rapidpm.workshop.java09.java.lang.StackTraceElementV001 - main\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke0\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.DelegatingMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njava.lang.reflect.Method - invoke\nmoduleVersion = null\nmoduleName = null\ncom.intellij.rt.execution.application.AppMain - main\n\n\n\n\nThe interesting thing here is, that the first and the last triple is without \na module -version and -name.\n\n\nTry to find out, why ;-)", 
            "title": "StackTraceElement"
        }, 
        {
            "location": "/java.lang/StackTraceElement/#new-methods-in-javalangstacktraceelement", 
            "text": "The class itself is inside the JDK since 1.4.  The StackTraceElement will now have the information about the module and module-version.\nFor this they added a new constructor   public StackTraceElement(String moduleName, \n                         String moduleVersion,\n                         String declaringClass, \n                         String methodName,String \n                         fileName, int lineNumber)  and the new getter methods  public String getModuleName()  and  public String getModuleVersion()  If you want to try this, play with the following.  public static void main(String[] args) {\n    try {\n      throw new RuntimeException( and go );\n    } catch (Exception e) {\n      final StackTraceElement[] stackTrace = e.getStackTrace();\n      for (StackTraceElement stackTraceElement : stackTrace) {\n        final String moduleName = stackTraceElement.getModuleName();\n        final String moduleVersion = stackTraceElement.getModuleVersion();\n        System.out.println( moduleVersion =   + moduleVersion);\n        System.out.println( moduleName =   + moduleName);\n        System.out.println(stackTraceElement.getClassName() +   -   + stackTraceElement.getMethodName());\n      }\n    }\n  }  The output at may machine was the following.  moduleVersion = null\nmoduleName = null\norg.rapidpm.workshop.java09.java.lang.StackTraceElementV001 - main\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke0\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.DelegatingMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njava.lang.reflect.Method - invoke\nmoduleVersion = null\nmoduleName = null\ncom.intellij.rt.execution.application.AppMain - main  The interesting thing here is, that the first and the last triple is without \na module -version and -name.  Try to find out, why ;-)", 
            "title": "New Methods in java.lang.StackTraceElement"
        }, 
        {
            "location": "/java.lang/StrictMath/", 
            "text": "New Methods in java.lang.StrictMath\n\n\nThe class itself is inside the JDK since 1.3.\n\n\npublic static long multiplyExact(long x, int y)\n\n\npublic static long multiplyFull(int x, int y)\n\n\npublic static long multiplyHigh(long x, long y)\n\n\npublic static long floorDiv(long x, int y)\n\n\npublic static int floorMod(long x, int y)\n\n\npublic static double fma(double a, double b, double c)\n\n\npublic static float fma(float a, float b, float c)", 
            "title": "StrictMath"
        }, 
        {
            "location": "/java.lang/StrictMath/#new-methods-in-javalangstrictmath", 
            "text": "The class itself is inside the JDK since 1.3.  public static long multiplyExact(long x, int y)  public static long multiplyFull(int x, int y)  public static long multiplyHigh(long x, long y)  public static long floorDiv(long x, int y)  public static int floorMod(long x, int y)  public static double fma(double a, double b, double c)  public static float fma(float a, float b, float c)", 
            "title": "New Methods in java.lang.StrictMath"
        }, 
        {
            "location": "/java.util.streams/Stream/", 
            "text": "New Methods inside the Streams API\n\n\nStream\n\n\nWhat are the news from Java8 to Java9?\n\n\ndefault Stream\n dropWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhileParallel = \n + collect);\n  }\n\n\n\n\nThe result will be.\n\n\ndropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]\n\n\n\n\ndefault Stream\n takeWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhileParallel = \n + collect);\n  }\n\n\n\n\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]\n\n\n\n\npublic static\n Stream\n ofNullable(T t)\n\n\npublic static\n Stream\n iterate(T seed, Predicate\n? super T\n hasNext, UnaryOperator\n next)\n\n\nCollectors\n\n\npublic static \n Collector\n flatMapping(Function\n? super T, ? extends Stream\n? extends U\n mapper,Collector\n? super U, A, R\n downstream)\n\n\npublic static \n Collector\n filtering(Predicate\n? super T\n predicate, Collector\n? super T, A, R\n downstream)\n\n\nIntStream\n\n\nsame as Stream\n\n\npublic static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", 
            "title": "Streams"
        }, 
        {
            "location": "/java.util.streams/Stream/#new-methods-inside-the-streams-api", 
            "text": "", 
            "title": "New Methods inside the Streams API"
        }, 
        {
            "location": "/java.util.streams/Stream/#stream", 
            "text": "What are the news from Java8 to Java9?  default Stream  dropWhile(Predicate ? super T  predicate)    public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhileParallel =   + collect);\n  }  The result will be.  dropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]  default Stream  takeWhile(Predicate ? super T  predicate)    public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhileParallel =   + collect);\n  }  takeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]  public static  Stream  ofNullable(T t)  public static  Stream  iterate(T seed, Predicate ? super T  hasNext, UnaryOperator  next)", 
            "title": "Stream"
        }, 
        {
            "location": "/java.util.streams/Stream/#collectors", 
            "text": "public static   Collector  flatMapping(Function ? super T, ? extends Stream ? extends U  mapper,Collector ? super U, A, R  downstream)  public static   Collector  filtering(Predicate ? super T  predicate, Collector ? super T, A, R  downstream)", 
            "title": "Collectors"
        }, 
        {
            "location": "/java.util.streams/Stream/#intstream", 
            "text": "same as Stream  public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", 
            "title": "IntStream"
        }
    ]
}