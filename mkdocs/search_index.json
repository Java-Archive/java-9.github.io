{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to java-9.org\n\n\nHere I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.\n\n\nCorresponding to this website I am creating demo codes that are available under\n\n\ngithub - java-9 / workshop_java09", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-java-9org", 
            "text": "Here I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.  Corresponding to this website I am creating demo codes that are available under  github - java-9 / workshop_java09", 
            "title": "Welcome to java-9.org"
        }, 
        {
            "location": "/jep102/", 
            "text": "JEP 102 - Process API Updates\n\n\nThis \nJEP\n is flagged with \ncore-lang\n.\n\n\njava.lang.ProcessBuilder\n\n\npublic static final Redirect DISCARD\n\n\njava.lang.Process\n\n\npublic boolean supportsNormalTermination()\n\n\npublic long getPid()\n\n\npublic CompletableFuture\n onExit()\n\n\npublic ProcessHandle toHandle()\n\n\npublic ProcessHandle.Info info()\n\n\npublic Stream\n children()\n\n\npublic Stream\n descendants()\n\n\njava.lang.ProcessHandle\n\n\njava.lang.Process\n\n\npublic boolean supportsNormalTermination()\n\n\npublic long getPid()\n\n\npublic CompletableFuture\n onExit()\n\n\npublic ProcessHandle toHandle()\n\n\npublic ProcessHandle.Info info()\n\n\npublic Stream\n children()\n\n\npublic Stream\n descendants()", 
            "title": "JEP102"
        }, 
        {
            "location": "/jep102/#jep-102-process-api-updates", 
            "text": "This  JEP  is flagged with  core-lang .", 
            "title": "JEP 102 - Process API Updates"
        }, 
        {
            "location": "/jep102/#javalangprocessbuilder", 
            "text": "public static final Redirect DISCARD", 
            "title": "java.lang.ProcessBuilder"
        }, 
        {
            "location": "/jep102/#javalangprocess", 
            "text": "public boolean supportsNormalTermination()  public long getPid()  public CompletableFuture  onExit()  public ProcessHandle toHandle()  public ProcessHandle.Info info()  public Stream  children()  public Stream  descendants()", 
            "title": "java.lang.Process"
        }, 
        {
            "location": "/jep102/#javalangprocesshandle", 
            "text": "", 
            "title": "java.lang.ProcessHandle"
        }, 
        {
            "location": "/jep102/#javalangprocess_1", 
            "text": "public boolean supportsNormalTermination()  public long getPid()  public CompletableFuture  onExit()  public ProcessHandle toHandle()  public ProcessHandle.Info info()  public Stream  children()  public Stream  descendants()", 
            "title": "java.lang.Process"
        }, 
        {
            "location": "/jep256/", 
            "text": "JEP259 - Stack-Walking API\n\n\nThis \nJEP\n is flagged wit \ncore\n.\n\n\nAll source codes I am using here you could find under \n\n\ngithub - java-9 / workshop_java09\n\n\nStackWalker\n\n\nThe StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few \ngetIntance(..)\n methods.\n\n\nFor this examples I created a class \nHolder\n to create a Stack you could walk through.\n\n\n public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println(\nend reached..\n);\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }\n\n\n\n\nWith this we are creating a well defined stack now.\n\n\n    new Holder(new Holder(new Holder(null) )).doWork();\n\n\n\n\nThe output here will be something like the following. Have in mind that I was starting this from inside IntelliJ\n\n\nend reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)", 
            "title": "JEP256"
        }, 
        {
            "location": "/jep256/#jep259-stack-walking-api", 
            "text": "This  JEP  is flagged wit  core .  All source codes I am using here you could find under   github - java-9 / workshop_java09", 
            "title": "JEP259 - Stack-Walking API"
        }, 
        {
            "location": "/jep256/#stackwalker", 
            "text": "The StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few  getIntance(..)  methods.  For this examples I created a class  Holder  to create a Stack you could walk through.   public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println( end reached.. );\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }  With this we are creating a well defined stack now.      new Holder(new Holder(new Holder(null) )).doWork();  The output here will be something like the following. Have in mind that I was starting this from inside IntelliJ  end reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)", 
            "title": "StackWalker"
        }, 
        {
            "location": "/java.lang/StrictMath/", 
            "text": "New Methods in java.lang.StrictMath\n\n\nThe class itself is inside the JDK since 1.3.\n\n\npublic static long multiplyExact(long x, int y)\n\n\npublic static long multiplyFull(int x, int y)\n\n\npublic static long multiplyHigh(long x, long y)\n\n\npublic static long floorDiv(long x, int y)\n\n\npublic static int floorMod(long x, int y)\n\n\npublic static double fma(double a, double b, double c)\n\n\npublic static float fma(float a, float b, float c)", 
            "title": "StrictMath"
        }, 
        {
            "location": "/java.lang/StrictMath/#new-methods-in-javalangstrictmath", 
            "text": "The class itself is inside the JDK since 1.3.  public static long multiplyExact(long x, int y)  public static long multiplyFull(int x, int y)  public static long multiplyHigh(long x, long y)  public static long floorDiv(long x, int y)  public static int floorMod(long x, int y)  public static double fma(double a, double b, double c)  public static float fma(float a, float b, float c)", 
            "title": "New Methods in java.lang.StrictMath"
        }, 
        {
            "location": "/java.util.streams/Stream/", 
            "text": "New Methods inside the Streams API\n\n\nStream\n\n\nWhat are the news from Java8 to Java9?\n\n\ndefault Stream\n dropWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhileParallel = \n + collect);\n  }\n\n\n\n\nThe result will be.\n\n\ndropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]\n\n\n\n\ndefault Stream\n takeWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhileParallel = \n + collect);\n  }\n\n\n\n\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]\n\n\n\n\npublic static\n Stream\n ofNullable(T t)\n\n\npublic static\n Stream\n iterate(T seed, Predicate\n? super T\n hasNext, UnaryOperator\n next)\n\n\nCollectors\n\n\npublic static \n Collector\n flatMapping(Function\n? super T, ? extends Stream\n? extends U\n mapper,Collector\n? super U, A, R\n downstream)\n\n\npublic static \n Collector\n filtering(Predicate\n? super T\n predicate, Collector\n? super T, A, R\n downstream)\n\n\nIntStream\n\n\nsame as Stream\n\n\npublic static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", 
            "title": "Streams"
        }, 
        {
            "location": "/java.util.streams/Stream/#new-methods-inside-the-streams-api", 
            "text": "", 
            "title": "New Methods inside the Streams API"
        }, 
        {
            "location": "/java.util.streams/Stream/#stream", 
            "text": "What are the news from Java8 to Java9?  default Stream  dropWhile(Predicate ? super T  predicate)    public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhileParallel =   + collect);\n  }  The result will be.  dropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]  default Stream  takeWhile(Predicate ? super T  predicate)    public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhileParallel =   + collect);\n  }  takeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]  public static  Stream  ofNullable(T t)  public static  Stream  iterate(T seed, Predicate ? super T  hasNext, UnaryOperator  next)", 
            "title": "Stream"
        }, 
        {
            "location": "/java.util.streams/Stream/#collectors", 
            "text": "public static   Collector  flatMapping(Function ? super T, ? extends Stream ? extends U  mapper,Collector ? super U, A, R  downstream)  public static   Collector  filtering(Predicate ? super T  predicate, Collector ? super T, A, R  downstream)", 
            "title": "Collectors"
        }, 
        {
            "location": "/java.util.streams/Stream/#intstream", 
            "text": "same as Stream  public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", 
            "title": "IntStream"
        }
    ]
}