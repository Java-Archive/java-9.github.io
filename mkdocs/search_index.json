{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to java-9.org\n\n\nHere I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.\n\n\nCorresponding to this website I am creating demo codes that are available under\n\n\ngithub - java-9 / workshop_java09", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-java-9org", 
            "text": "Here I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.  Corresponding to this website I am creating demo codes that are available under  github - java-9 / workshop_java09", 
            "title": "Welcome to java-9.org"
        }, 
        {
            "location": "/jep102/", 
            "text": "Process API Updates\n\n\nThis \nJEP\n is flagged with \ncore-lang\n.\n\n\njava.lang.ProcessBuilder\n\n\npublic static final Redirect DISCARD\n\n\njava.lang.Process\n\n\npublic boolean supportsNormalTermination()\n\n\npublic long getPid()\n\n\npublic CompletableFuture\n onExit()\n\n\npublic ProcessHandle toHandle()\n\n\npublic ProcessHandle.Info info()\n\n\npublic Stream\n children()\n\n\npublic Stream\n descendants()\n\n\njava.lang.ProcessHandle\n\n\njava.lang.Process\n\n\npublic boolean supportsNormalTermination()\n\n\npublic long getPid()\n\n\npublic CompletableFuture\n onExit()\n\n\npublic ProcessHandle toHandle()\n\n\npublic ProcessHandle.Info info()\n\n\npublic Stream\n children()\n\n\npublic Stream\n descendants()", 
            "title": "JEP102"
        }, 
        {
            "location": "/jep102/#process-api-updates", 
            "text": "This  JEP  is flagged with  core-lang .", 
            "title": "Process API Updates"
        }, 
        {
            "location": "/jep102/#javalangprocessbuilder", 
            "text": "public static final Redirect DISCARD", 
            "title": "java.lang.ProcessBuilder"
        }, 
        {
            "location": "/jep102/#javalangprocess", 
            "text": "public boolean supportsNormalTermination()  public long getPid()  public CompletableFuture  onExit()  public ProcessHandle toHandle()  public ProcessHandle.Info info()  public Stream  children()  public Stream  descendants()", 
            "title": "java.lang.Process"
        }, 
        {
            "location": "/jep102/#javalangprocesshandle", 
            "text": "", 
            "title": "java.lang.ProcessHandle"
        }, 
        {
            "location": "/jep102/#javalangprocess_1", 
            "text": "public boolean supportsNormalTermination()  public long getPid()  public CompletableFuture  onExit()  public ProcessHandle toHandle()  public ProcessHandle.Info info()  public Stream  children()  public Stream  descendants()", 
            "title": "java.lang.Process"
        }, 
        {
            "location": "/jep256/", 
            "text": "Stack-Walking API\n\n\nThis \nJEP\n is flagged wit \ncore\n.\n\n\nAll source codes I am using here you could find under \n\n\ngithub - java-9 / workshop_java09\n\n\nStackWalker\n\n\nThe StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few \ngetIntance(..)\n methods.\n\n\nFor this examples I created a class \nHolder\n to create a Stack you could walk through.\n\n\n public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println(\nend reached..\n);\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }\n\n\n\n\nWith this we are creating a well defined stack now.\n\n\n    new Holder(new Holder(new Holder(null) )).doWork();\n\n\n\n\nThe output here will be something like the following. Have in mind that I was starting this from inside IntelliJ\n\n\nend reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n\n\n\n\nmore detailed informations\n\n\nYou could get more informations out of the StackWalker as you saw before.\nFor this the class Holder will be extended now a little bit more.\n\n\n public static class Holder002 {\n    private Holder002 holder;\n\n    public Holder002(final Holder002 holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println(\nend reached..\n);\n        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n            .forEach(stackFrame -\n {\n              final int byteCodeIndex = stackFrame.getByteCodeIndex();\n              System.out.println(\nbyteCodeIndex = \n + byteCodeIndex);\n              // byteCode Index :\n              final String className = stackFrame.getClassName();\n              System.out.println(\nclassName = \n + className);\n              final Class\n?\n declaringClass = stackFrame.getDeclaringClass();\n              System.out.println(\ndeclaringClass = \n + declaringClass);\n              final String fileName = stackFrame.getFileName();\n              System.out.println(\nfileName = \n + fileName);\n              final int lineNumber = stackFrame.getLineNumber();\n              System.out.println(\nlineNumber = \n + lineNumber);\n              final String methodName = stackFrame.getMethodName();\n              System.out.println(\nmethodName = \n + methodName);\n            });\n      } else {\n        holder.doWork();\n      }\n    }\n  }\n\n\n\n\nHere we have to use the first time a defined \ngetInstance(..)\n method to get all informations. \nIf you are not using the right \nStackWalker.Option\n the result will be an exception.\nYou have three Options.\n\n\n\n\n\n\nRETAIN_CLASS_REFERENCE:\n getCallerClass() and getDeclaringClass() will work\n\n\n\n\n\n\nSHOW_REFLECT_FRAMES:\n This will show all reflections frames that are hidden by default\n\n\n\n\n\n\nSHOW_HIDDEN_FRAMES:\n This will show all reflection frames and additionally implementation specific internal frames\n\n\n\n\n\n\nTwo things are not used in this example.\nFirst is the method \nisNativeMethod()\n to identify if the caller method in the stack is a JVM native one \nand second \ntoStackTraceElement()\n to convert this information to a StackTraceElement that you \ncould use to generate a more detailed Exception-Message.\n\n\nfilter the stack\n\n\nSometime you will have to filter a few of this information out that is given by the StackWalker.\nFor this you can work with the stream as done before at other places. The method \nwalk(..)\n will \ngive you the possibility to add a Predicate that will be used to filter the result.\nHere I only want to have all elements from a specific namespace. \n(btw: the method ``takeWhile()```  is new too, check for this the section about Streams)\n\n\nStackWalker\n            .getInstance()\n            .walk(sfStream -\n sfStream\n                .takeWhile(frame -\n frame.getClassName().startsWith(\norg.rapidpm\n))\n                .collect(Collectors.toList()))\n            .forEach(System.out::println);\n\n\n\n\nsometimes you only want to know...\n\n\nYes, sometimes you only want to know the caller class. Don\u00b4t worry, there is a simple solution.\n\n\nfinal Class\n?\n callerClass = StackWalker\n        .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) //Option needed\n        .getCallerClass();\n    System.out.println(\ncallerClass = \n + callerClass);", 
            "title": "JEP256"
        }, 
        {
            "location": "/jep256/#stack-walking-api", 
            "text": "This  JEP  is flagged wit  core .  All source codes I am using here you could find under   github - java-9 / workshop_java09", 
            "title": "Stack-Walking API"
        }, 
        {
            "location": "/jep256/#stackwalker", 
            "text": "The StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few  getIntance(..)  methods.  For this examples I created a class  Holder  to create a Stack you could walk through.   public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println( end reached.. );\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }  With this we are creating a well defined stack now.      new Holder(new Holder(new Holder(null) )).doWork();  The output here will be something like the following. Have in mind that I was starting this from inside IntelliJ  end reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)  more detailed informations  You could get more informations out of the StackWalker as you saw before.\nFor this the class Holder will be extended now a little bit more.   public static class Holder002 {\n    private Holder002 holder;\n\n    public Holder002(final Holder002 holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println( end reached.. );\n        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n            .forEach(stackFrame -  {\n              final int byteCodeIndex = stackFrame.getByteCodeIndex();\n              System.out.println( byteCodeIndex =   + byteCodeIndex);\n              // byteCode Index :\n              final String className = stackFrame.getClassName();\n              System.out.println( className =   + className);\n              final Class ?  declaringClass = stackFrame.getDeclaringClass();\n              System.out.println( declaringClass =   + declaringClass);\n              final String fileName = stackFrame.getFileName();\n              System.out.println( fileName =   + fileName);\n              final int lineNumber = stackFrame.getLineNumber();\n              System.out.println( lineNumber =   + lineNumber);\n              final String methodName = stackFrame.getMethodName();\n              System.out.println( methodName =   + methodName);\n            });\n      } else {\n        holder.doWork();\n      }\n    }\n  }  Here we have to use the first time a defined  getInstance(..)  method to get all informations. \nIf you are not using the right  StackWalker.Option  the result will be an exception.\nYou have three Options.    RETAIN_CLASS_REFERENCE:  getCallerClass() and getDeclaringClass() will work    SHOW_REFLECT_FRAMES:  This will show all reflections frames that are hidden by default    SHOW_HIDDEN_FRAMES:  This will show all reflection frames and additionally implementation specific internal frames    Two things are not used in this example.\nFirst is the method  isNativeMethod()  to identify if the caller method in the stack is a JVM native one \nand second  toStackTraceElement()  to convert this information to a StackTraceElement that you \ncould use to generate a more detailed Exception-Message.  filter the stack  Sometime you will have to filter a few of this information out that is given by the StackWalker.\nFor this you can work with the stream as done before at other places. The method  walk(..)  will \ngive you the possibility to add a Predicate that will be used to filter the result.\nHere I only want to have all elements from a specific namespace. \n(btw: the method ``takeWhile()```  is new too, check for this the section about Streams)  StackWalker\n            .getInstance()\n            .walk(sfStream -  sfStream\n                .takeWhile(frame -  frame.getClassName().startsWith( org.rapidpm ))\n                .collect(Collectors.toList()))\n            .forEach(System.out::println);  sometimes you only want to know...  Yes, sometimes you only want to know the caller class. Don\u00b4t worry, there is a simple solution.  final Class ?  callerClass = StackWalker\n        .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) //Option needed\n        .getCallerClass();\n    System.out.println( callerClass =   + callerClass);", 
            "title": "StackWalker"
        }, 
        {
            "location": "/java.lang/StrictMath/", 
            "text": "New Methods in java.lang.StrictMath\n\n\nThe class itself is inside the JDK since 1.3.\n\n\npublic static long multiplyExact(long x, int y)\n\n\npublic static long multiplyFull(int x, int y)\n\n\npublic static long multiplyHigh(long x, long y)\n\n\npublic static long floorDiv(long x, int y)\n\n\npublic static int floorMod(long x, int y)\n\n\npublic static double fma(double a, double b, double c)\n\n\npublic static float fma(float a, float b, float c)", 
            "title": "StrictMath"
        }, 
        {
            "location": "/java.lang/StrictMath/#new-methods-in-javalangstrictmath", 
            "text": "The class itself is inside the JDK since 1.3.  public static long multiplyExact(long x, int y)  public static long multiplyFull(int x, int y)  public static long multiplyHigh(long x, long y)  public static long floorDiv(long x, int y)  public static int floorMod(long x, int y)  public static double fma(double a, double b, double c)  public static float fma(float a, float b, float c)", 
            "title": "New Methods in java.lang.StrictMath"
        }, 
        {
            "location": "/java.util.streams/Stream/", 
            "text": "New Methods inside the Streams API\n\n\nStream\n\n\nWhat are the news from Java8 to Java9?\n\n\ndefault Stream\n dropWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhileParallel = \n + collect);\n  }\n\n\n\n\nThe result will be.\n\n\ndropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]\n\n\n\n\ndefault Stream\n takeWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhileParallel = \n + collect);\n  }\n\n\n\n\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]\n\n\n\n\npublic static\n Stream\n ofNullable(T t)\n\n\npublic static\n Stream\n iterate(T seed, Predicate\n? super T\n hasNext, UnaryOperator\n next)\n\n\nCollectors\n\n\npublic static \n Collector\n flatMapping(Function\n? super T, ? extends Stream\n? extends U\n mapper,Collector\n? super U, A, R\n downstream)\n\n\npublic static \n Collector\n filtering(Predicate\n? super T\n predicate, Collector\n? super T, A, R\n downstream)\n\n\nIntStream\n\n\nsame as Stream\n\n\npublic static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", 
            "title": "Streams"
        }, 
        {
            "location": "/java.util.streams/Stream/#new-methods-inside-the-streams-api", 
            "text": "", 
            "title": "New Methods inside the Streams API"
        }, 
        {
            "location": "/java.util.streams/Stream/#stream", 
            "text": "What are the news from Java8 to Java9?  default Stream  dropWhile(Predicate ? super T  predicate)    public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhileParallel =   + collect);\n  }  The result will be.  dropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]  default Stream  takeWhile(Predicate ? super T  predicate)    public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhileParallel =   + collect);\n  }  takeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]  public static  Stream  ofNullable(T t)  public static  Stream  iterate(T seed, Predicate ? super T  hasNext, UnaryOperator  next)", 
            "title": "Stream"
        }, 
        {
            "location": "/java.util.streams/Stream/#collectors", 
            "text": "public static   Collector  flatMapping(Function ? super T, ? extends Stream ? extends U  mapper,Collector ? super U, A, R  downstream)  public static   Collector  filtering(Predicate ? super T  predicate, Collector ? super T, A, R  downstream)", 
            "title": "Collectors"
        }, 
        {
            "location": "/java.util.streams/Stream/#intstream", 
            "text": "same as Stream  public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", 
            "title": "IntStream"
        }
    ]
}