{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to java-9.org\n\n\nHere I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.\n\n\nCorresponding to this website I am creating demo codes that are available under\n\n\ngithub - java-9 / workshop_java09\n\n\nthis website is still under construction, updates are nearly every day", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-java-9org", 
            "text": "Here I want to describe the new things from Java9 compared to Java8. \nI will organize the most stuff with the corresponding JEP\u00b4s.  Corresponding to this website I am creating demo codes that are available under  github - java-9 / workshop_java09  this website is still under construction, updates are nearly every day", 
            "title": "Welcome to java-9.org"
        }, 
        {
            "location": "/JEP102/", 
            "text": "Process API Updates\n\n\nThis \nJEP\n is flagged with \ncore-lang\n.\n\n\njava.lang.ProcessBuilder\n\n\npublic static final Redirect DISCARD\n\n\nIf you are using the ProcessBuilder, you could define where \nthe output will be redirected.\nNew here in Java 9 is \ndev/null\n ;-)\n\n\nFirst we are writing all to the stdout.\n\n\npublic static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    // only if installed\n    final ProcessBuilder command = processBuilder.command(\njava\n, \n-version\n); \n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n          .redirectError(ProcessBuilder.Redirect.INHERIT);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n\n  }\n\n\n\n\nIn this version you will see something like the following.\n\n\njava version \n1.8.0_112\n\nJava(TM) SE Runtime Environment (build 1.8.0_112-b16)\nJava HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)\n\n\n\n\nIf we are the new redirect we will see..... nothing...\n\n\npublic static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    final ProcessBuilder command = processBuilder.command(\njava\n, \n-version\n); // only if installed\n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.DISCARD)\n          .redirectError(ProcessBuilder.Redirect.DISCARD);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n\n\n\n\njava.lang.ProcessHandle\n\n\nWith this we got a possibility to manage the process easy and a \nway to get information's about the started process itself.\n\n\nFirst we will start to get some information's about the process itself we are running.\n\n\n    final ProcessHandle current = ProcessHandle.current();\n    final long pid = current.getPid();\n    System.out.println(\npid = \n + pid);\n\n\n\n\nHere we are asking for the PID of our own process. But we could get easily \na Stream of all running processes.\n\n\n    final Stream\nProcessHandle\n processHandleStream = ProcessHandle.allProcesses();\n\n    processHandleStream.forEach( p -\n {\n          final long pid = p.getPid();\n          System.out.println(\npid = \n + pid);\n        }\n    );\n\n\n\n\nBut if you already know the PID, you can get the ProcessHandle for this as well with the method \nof(..)\n\n\n    final ProcessHandle processOne = ProcessHandle.of(1).get();\n\n\n\n\nFrom this you could get all child processes as a Stream.\n\n\n    processOne.children().forEach(p -\n System.out.println(\np = \n + p.info() ));\n\n\n\n\nOr you could get the father. \n\n\n    ProcessHandle\n        .current()\n        .parent()\n        .ifPresent(f -\n out.println(\nf.getPid() = \n + f.getPid()));\n\n\n\n\nIf you want to have a children plus sub-children of a process, you could use the method \ndescendants()\n\n\n    ProcessHandle\n        .current()\n        .descendants()\n        .forEach(p -\n out.println(\np = \n + p.info() ));\n\n\n\n\nProcessHandle.Info\n\n\nThis class will hold a few informations together , like a status snapshot. \nAll values are wrapped into an Optional. \n\n\n      final ProcessHandle start = ProcessHandle.current();\n      final ProcessHandle.Info info = start.info();\n\n      info.commandLine().ifPresent(a -\n out.println(\ncommandLine = \n + a));\n      info.command().ifPresent(a -\n out.println(\ncommand = \n + a));\n      info.arguments().ifPresent(a -\n out.println(\narguments = \n + asList(a)));\n      info.startInstant().ifPresent(t -\n out.println(\nstartInstant = \n + ofInstant(t, systemDefault())));\n      info.totalCpuDuration().ifPresent(d -\n out.println(\nd [ms] = \n + d.toMillis()));\n      info.user().ifPresent(u -\n out.println(\nuser = \n + u));\n\n\n\n\njava.lang.Process\n\n\nThe class Process itself is since JDK 1.0 available. But still it will be improved.\nWith Java9 we got a few more methods to play with.\nA few of them are for information only, like \npublic boolean supportsNormalTermination()\n\nor \npublic long getPid()\n. The methods \npublic Stream\nProcessHandle\n children()\n and \n\n### public Stream\nProcessHandle\n descendants()\n we know from the class ProcessHandle already.\n\n\nTo convert into a ProcessHandle we could use the method \ntoHandle()\n and the delegator \ninfo()\n\nwill give us the ProcessHandle.Info instance.\n\n\nBut there is a really nice new method available.\n\n\npublic CompletableFuture\n onExit()\n\n\nWith the method \nonExit()\n  we are able to create async tree\u00b4s of processes. \nAn easy example you could find here \nJEP102 - V006\n \n\n\nThe basic idea behind ist the concatenation of CompletableFuture\u00b4s.\nWe will start with the definition of a Function that will transform a \nString\n into a \n\nSupplier\nProcessBuilder\n\n\n  private static Function\nString, Supplier\nProcessBuilder\n commandSupplierFunction\n      = command -\n () -\n new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);\n\n\n\n\n\nWith this we could define easily \nCompletableFuture\nOptional\nProcess\n \nto describe commands we would like to start.\n\n\n        final CompletableFuture\nOptional\nProcess\n commandJConsole = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply(\njconsole\n))\n        .handleAsync(JEP102V006.START_PROCESS);\n\n    final CompletableFuture\nOptional\nProcess\n commandJMC = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply(\njmc\n))\n        .handleAsync(JEP102V006.START_PROCESS);\n\n\n\n\n\nNow we have to combine all processes together. Here in this example I want to start \nconcurrently \njconsole\n and \nJava Mission Control\n. After I closed both processes \nI want to start \njvisualvm\n. \n\n\ncommandJConsole\n        .thenCombineAsync(commandJMC, (jconsoleOpt, jmcOpt) -\n {\n          System.out.println(\nboth proc. are started? \n + jconsoleOpt.isPresent() + \n - \n + jmcOpt.isPresent());\n          final CompletableFuture\nProcess\n jconsoleProcess = jconsoleOpt.get().onExit();\n          final CompletableFuture\nProcess\n jmcProcess = jmcOpt.get().onExit();\n          return jconsoleProcess\n              .thenCombineAsync(jmcProcess, (jconsole, jmc) -\n {\n                //both are done -\n work on result\n                System.out.println(\njconsole.getPid() = \n + jconsole.getPid());\n                System.out.println(\njmc.getPid() = \n + jmc.getPid());\n                return CompletableFuture //-\n create the next COMMAND_SUPPLIER_FUNCTION\n                    .supplyAsync(commandSupplierFunction.apply(\njvisualvm\n));\n              })\n              .thenComposeAsync(cf -\n cf); // flatMap\n        })\n        .thenComposeAsync(cf -\n cf) // flatMap\n        .handleAsync(JEP102V006.START_PROCESS)  // start third proc\n        .join()\n        .ifPresent(p -\n p\n            .onExit()\n            .thenAccept(process -\n System.out.println(\nprocess.getPid() = \n + process.getPid()))\n            .join()\n        );\n\n\n\n\nAs you could see, the main task is not tooooooo difficult. \nBut this is not nice, if you have to write this a few times.\nThis is a good point to start with a few refactorings.\n\n\nLets start with the way to start a process. This is generic and we could write it like the following.\n\n\npublic static final BiFunction\nProcessBuilder, Throwable, Optional\nProcess\n START_PROCESS = (processBuilder, throwable) -\n {\n    try {\n      System.out.println(\nstartProcess = \n + processBuilder.command());\n      return Optional.of(processBuilder.start());\n    } catch (IOException e) {\n      e.printStackTrace();\n      return Optional.empty();\n    }\n  };\n\n\n\n\nFor this we need a way to define and create a \nSupplier\nProcessBuilder\n\n\n  public static final Function\nString, Supplier\nProcessBuilder\n COMMAND_SUPPLIER_FUNCTION\n      = command -\n () -\n new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);\n\n\n\n\nBoth together will start the command...\n\n\n  public static final Function\nString, CompletableFuture\nOptional\nProcess\n CREATE_AND_START_PROCESS = command\n      -\n CompletableFuture\n          .supplyAsync(COMMAND_SUPPLIER_FUNCTION.apply(command))\n          .handleAsync(START_PROCESS);\n\n\n\n\n\nNow we will get the little bit complex part. We want to join process-results and start a new one. \nThe most of it is generic and could be extracted into a FunctionalInterface.\n\n\n  @FunctionalInterface\n  public interface JoinProcesses extends BiFunction\nCompletableFuture\nOptional\nProcess\n,\n                                                    CompletableFuture\nOptional\nProcess\n,\n                                                    CompletableFuture\nOptional\nProcess\n {\n\n    BiFunction\nCompletableFuture\nProcess\n,\n               CompletableFuture\nProcess\n,\n               BiFunction\nProcess,\n                          Process,\n                          Supplier\nProcessBuilder\n processResultBiFunction();\n\n    @Override\n    default CompletableFuture\nOptional\nProcess\n apply(CompletableFuture\nOptional\nProcess\n procOptA,\n                                                       CompletableFuture\nOptional\nProcess\n procOptB) {\n      // here more specific exception handlimg or default behavior\n      // System.out.println(\nboth proc. are started? \n + procOptA.isPresent() + \n - \n + procOptB.isPresent());\n      final CompletableFuture\nProcess\n procA = procOptA.thenComposeAsync(p -\n p.get().onExit());\n      final CompletableFuture\nProcess\n procB = procOptB.thenComposeAsync(p -\n p.get().onExit());\n      return procA\n          .thenCombineAsync(procB, processResultBiFunction().apply(procA, procB))\n          .handleAsync((processBuilderSupplier, throwable)\n              -\n JEP102V006.START_PROCESS.apply(processBuilderSupplier.get(), throwable));\n    }\n  }\n\n\n\n\nThe part that must be defined by the developer is the method \nprocessResultBiFunction()\n. \nThe task here will be to deal with the two\nresults from the processes and decide what would be the next one to start.\n\n\nFrom the developer point of few we have to define two things now.\nFirst one is, what are the processes to start and combine. \n\n\n((JEP102V006.JoinProcesses) () -\n processResults)\n        .apply(JEP102V006.CREATE_AND_START_PROCESS.apply(\njconsole\n),\n            JEP102V006.CREATE_AND_START_PROCESS.apply(\njmc\n))\n        .join()\n        .ifPresent(p -\n p\n            .onExit()\n            .thenAccept(process -\n System.out.println(\nprocess.getPid() = \n + process.getPid()))\n            .join()\n        );\n\n\n\n\nAnd second would be the dealing with the result of the \nprocesses and the decision what would be the next command.\n\n\n\nprivate static final BiFunction\nCompletableFuture\nProcess\n,\n                                  CompletableFuture\nProcess\n,\n                                  BiFunction\nProcess,\n                                             Process,\n                                             Supplier\nProcessBuilder\n processResults\n      = (procCFA, procCFB) -\n {\n    final Process procA = procCFA.join();\n    final Process procB = procCFB.join();\n    System.out.println(\njconsole.getPid() = \n + procA.getPid());\n    System.out.println(\njmc.getPid() = \n + procB.getPid());\n    // work on result....\n    return (process, process2) -\n JEP102V006.COMMAND_SUPPLIER_FUNCTION.apply(\njvisualvm\n);\n  };\n\n\n\n\nNow we are able to define a tree of external processes nearly fully async, based on \nCompletableFuture", 
            "title": "JEP102"
        }, 
        {
            "location": "/JEP102/#process-api-updates", 
            "text": "This  JEP  is flagged with  core-lang .", 
            "title": "Process API Updates"
        }, 
        {
            "location": "/JEP102/#javalangprocessbuilder", 
            "text": "", 
            "title": "java.lang.ProcessBuilder"
        }, 
        {
            "location": "/JEP102/#public-static-final-redirect-discard", 
            "text": "If you are using the ProcessBuilder, you could define where \nthe output will be redirected.\nNew here in Java 9 is  dev/null  ;-)  First we are writing all to the stdout.  public static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    // only if installed\n    final ProcessBuilder command = processBuilder.command( java ,  -version ); \n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n          .redirectError(ProcessBuilder.Redirect.INHERIT);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n\n  }  In this version you will see something like the following.  java version  1.8.0_112 \nJava(TM) SE Runtime Environment (build 1.8.0_112-b16)\nJava HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)  If we are the new redirect we will see..... nothing...  public static void main(String[] args) {\n    final ProcessBuilder processBuilder = new ProcessBuilder();\n    final ProcessBuilder command = processBuilder.command( java ,  -version ); // only if installed\n    try {\n      command\n          .inheritIO()\n          .redirectOutput(ProcessBuilder.Redirect.DISCARD)\n          .redirectError(ProcessBuilder.Redirect.DISCARD);\n      final Process start = command.start();\n      final int waitFor = start.waitFor();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n  }", 
            "title": "public static final Redirect DISCARD"
        }, 
        {
            "location": "/JEP102/#javalangprocesshandle", 
            "text": "With this we got a possibility to manage the process easy and a \nway to get information's about the started process itself.  First we will start to get some information's about the process itself we are running.      final ProcessHandle current = ProcessHandle.current();\n    final long pid = current.getPid();\n    System.out.println( pid =   + pid);  Here we are asking for the PID of our own process. But we could get easily \na Stream of all running processes.      final Stream ProcessHandle  processHandleStream = ProcessHandle.allProcesses();\n\n    processHandleStream.forEach( p -  {\n          final long pid = p.getPid();\n          System.out.println( pid =   + pid);\n        }\n    );  But if you already know the PID, you can get the ProcessHandle for this as well with the method  of(..)      final ProcessHandle processOne = ProcessHandle.of(1).get();  From this you could get all child processes as a Stream.      processOne.children().forEach(p -  System.out.println( p =   + p.info() ));  Or you could get the father.       ProcessHandle\n        .current()\n        .parent()\n        .ifPresent(f -  out.println( f.getPid() =   + f.getPid()));  If you want to have a children plus sub-children of a process, you could use the method  descendants()      ProcessHandle\n        .current()\n        .descendants()\n        .forEach(p -  out.println( p =   + p.info() ));", 
            "title": "java.lang.ProcessHandle"
        }, 
        {
            "location": "/JEP102/#processhandleinfo", 
            "text": "This class will hold a few informations together , like a status snapshot. \nAll values are wrapped into an Optional.         final ProcessHandle start = ProcessHandle.current();\n      final ProcessHandle.Info info = start.info();\n\n      info.commandLine().ifPresent(a -  out.println( commandLine =   + a));\n      info.command().ifPresent(a -  out.println( command =   + a));\n      info.arguments().ifPresent(a -  out.println( arguments =   + asList(a)));\n      info.startInstant().ifPresent(t -  out.println( startInstant =   + ofInstant(t, systemDefault())));\n      info.totalCpuDuration().ifPresent(d -  out.println( d [ms] =   + d.toMillis()));\n      info.user().ifPresent(u -  out.println( user =   + u));", 
            "title": "ProcessHandle.Info"
        }, 
        {
            "location": "/JEP102/#javalangprocess", 
            "text": "The class Process itself is since JDK 1.0 available. But still it will be improved.\nWith Java9 we got a few more methods to play with.\nA few of them are for information only, like  public boolean supportsNormalTermination() \nor  public long getPid() . The methods  public Stream ProcessHandle  children()  and  ### public Stream ProcessHandle  descendants()  we know from the class ProcessHandle already.  To convert into a ProcessHandle we could use the method  toHandle()  and the delegator  info() \nwill give us the ProcessHandle.Info instance.  But there is a really nice new method available.", 
            "title": "java.lang.Process"
        }, 
        {
            "location": "/JEP102/#public-completablefuture-onexit", 
            "text": "With the method  onExit()   we are able to create async tree\u00b4s of processes. \nAn easy example you could find here  JEP102 - V006    The basic idea behind ist the concatenation of CompletableFuture\u00b4s.\nWe will start with the definition of a Function that will transform a  String  into a  Supplier ProcessBuilder    private static Function String, Supplier ProcessBuilder  commandSupplierFunction\n      = command -  () -  new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);  With this we could define easily  CompletableFuture Optional Process  \nto describe commands we would like to start.          final CompletableFuture Optional Process  commandJConsole = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply( jconsole ))\n        .handleAsync(JEP102V006.START_PROCESS);\n\n    final CompletableFuture Optional Process  commandJMC = CompletableFuture\n        .supplyAsync(commandSupplierFunction.apply( jmc ))\n        .handleAsync(JEP102V006.START_PROCESS);  Now we have to combine all processes together. Here in this example I want to start \nconcurrently  jconsole  and  Java Mission Control . After I closed both processes \nI want to start  jvisualvm .   commandJConsole\n        .thenCombineAsync(commandJMC, (jconsoleOpt, jmcOpt) -  {\n          System.out.println( both proc. are started?   + jconsoleOpt.isPresent() +   -   + jmcOpt.isPresent());\n          final CompletableFuture Process  jconsoleProcess = jconsoleOpt.get().onExit();\n          final CompletableFuture Process  jmcProcess = jmcOpt.get().onExit();\n          return jconsoleProcess\n              .thenCombineAsync(jmcProcess, (jconsole, jmc) -  {\n                //both are done -  work on result\n                System.out.println( jconsole.getPid() =   + jconsole.getPid());\n                System.out.println( jmc.getPid() =   + jmc.getPid());\n                return CompletableFuture //-  create the next COMMAND_SUPPLIER_FUNCTION\n                    .supplyAsync(commandSupplierFunction.apply( jvisualvm ));\n              })\n              .thenComposeAsync(cf -  cf); // flatMap\n        })\n        .thenComposeAsync(cf -  cf) // flatMap\n        .handleAsync(JEP102V006.START_PROCESS)  // start third proc\n        .join()\n        .ifPresent(p -  p\n            .onExit()\n            .thenAccept(process -  System.out.println( process.getPid() =   + process.getPid()))\n            .join()\n        );  As you could see, the main task is not tooooooo difficult. \nBut this is not nice, if you have to write this a few times.\nThis is a good point to start with a few refactorings.  Lets start with the way to start a process. This is generic and we could write it like the following.  public static final BiFunction ProcessBuilder, Throwable, Optional Process  START_PROCESS = (processBuilder, throwable) -  {\n    try {\n      System.out.println( startProcess =   + processBuilder.command());\n      return Optional.of(processBuilder.start());\n    } catch (IOException e) {\n      e.printStackTrace();\n      return Optional.empty();\n    }\n  };  For this we need a way to define and create a  Supplier ProcessBuilder    public static final Function String, Supplier ProcessBuilder  COMMAND_SUPPLIER_FUNCTION\n      = command -  () -  new ProcessBuilder()\n      .command(command)\n      .inheritIO()\n      .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n      .redirectError(ProcessBuilder.Redirect.INHERIT);  Both together will start the command...    public static final Function String, CompletableFuture Optional Process  CREATE_AND_START_PROCESS = command\n      -  CompletableFuture\n          .supplyAsync(COMMAND_SUPPLIER_FUNCTION.apply(command))\n          .handleAsync(START_PROCESS);  Now we will get the little bit complex part. We want to join process-results and start a new one. \nThe most of it is generic and could be extracted into a FunctionalInterface.    @FunctionalInterface\n  public interface JoinProcesses extends BiFunction CompletableFuture Optional Process ,\n                                                    CompletableFuture Optional Process ,\n                                                    CompletableFuture Optional Process  {\n\n    BiFunction CompletableFuture Process ,\n               CompletableFuture Process ,\n               BiFunction Process,\n                          Process,\n                          Supplier ProcessBuilder  processResultBiFunction();\n\n    @Override\n    default CompletableFuture Optional Process  apply(CompletableFuture Optional Process  procOptA,\n                                                       CompletableFuture Optional Process  procOptB) {\n      // here more specific exception handlimg or default behavior\n      // System.out.println( both proc. are started?   + procOptA.isPresent() +   -   + procOptB.isPresent());\n      final CompletableFuture Process  procA = procOptA.thenComposeAsync(p -  p.get().onExit());\n      final CompletableFuture Process  procB = procOptB.thenComposeAsync(p -  p.get().onExit());\n      return procA\n          .thenCombineAsync(procB, processResultBiFunction().apply(procA, procB))\n          .handleAsync((processBuilderSupplier, throwable)\n              -  JEP102V006.START_PROCESS.apply(processBuilderSupplier.get(), throwable));\n    }\n  }  The part that must be defined by the developer is the method  processResultBiFunction() . \nThe task here will be to deal with the two\nresults from the processes and decide what would be the next one to start.  From the developer point of few we have to define two things now.\nFirst one is, what are the processes to start and combine.   ((JEP102V006.JoinProcesses) () -  processResults)\n        .apply(JEP102V006.CREATE_AND_START_PROCESS.apply( jconsole ),\n            JEP102V006.CREATE_AND_START_PROCESS.apply( jmc ))\n        .join()\n        .ifPresent(p -  p\n            .onExit()\n            .thenAccept(process -  System.out.println( process.getPid() =   + process.getPid()))\n            .join()\n        );  And second would be the dealing with the result of the \nprocesses and the decision what would be the next command.  \nprivate static final BiFunction CompletableFuture Process ,\n                                  CompletableFuture Process ,\n                                  BiFunction Process,\n                                             Process,\n                                             Supplier ProcessBuilder  processResults\n      = (procCFA, procCFB) -  {\n    final Process procA = procCFA.join();\n    final Process procB = procCFB.join();\n    System.out.println( jconsole.getPid() =   + procA.getPid());\n    System.out.println( jmc.getPid() =   + procB.getPid());\n    // work on result....\n    return (process, process2) -  JEP102V006.COMMAND_SUPPLIER_FUNCTION.apply( jvisualvm );\n  };  Now we are able to define a tree of external processes nearly fully async, based on  CompletableFuture", 
            "title": "public CompletableFuture onExit()"
        }, 
        {
            "location": "/JEP110/", 
            "text": "HTTP/2 Client\n\n\nThis \nJEP\n is flagged with \ncore-net\n.", 
            "title": "JEP110"
        }, 
        {
            "location": "/JEP110/#http2-client", 
            "text": "This  JEP  is flagged with  core-net .", 
            "title": "HTTP/2 Client"
        }, 
        {
            "location": "/JEP213/", 
            "text": "Milling Project Coin\n\n\nThis \nJEP\n is flagged wit \ntools\u2009/\u2009javac\n.\n\n\nThis JEP is divided in five parts. This is more or less a collections of improvements\nof things we got with Java7 and Java8.\n\n\nAllow @SafeVargs on private instance methods.\n\n\nThe @SafeVarargs annotation can only be applied to methods which cannot be overridden, \nlike static final or public final methods.\nWith Java9 we could do this now with private methods, too.\nEven if they are (static/unstatic) final or not.\n\n\n  @SafeVarargs\n  public static \nT\n void myStaticMethod(T... args) {\n    // do something\n  }  \n\n  @SafeVarargs\n  public final \nT\n void myUnStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private final \nT\n void myPrivateUnStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private  \nT\n void myPrivateUnFinalUnStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private static final \nT\n void myPrivateStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private  static \nT\n void myPrivateUnFinalStaticMethod(T... args) {\n    // do something\n  }\n\n\n\n\nAllow effectively-final variables to be used as resources in the try-with-resources statement.\n\n\nThe target here was the reduction of boilderplate code. In Java7 and Java8 you had to write the following\nlines to deal with an \nAutoClosable\n\n\n  public void doSomethingWithOld(ByteArrayInputStream bais) throws Exception {\n    try(final ByteArrayInputStream stream = bais) {\n      final byte[] readAllBytes = stream.readAllBytes();\n    }\n  }  \n\n\n\n\nIn Java9 you could write it without declaring a new variable. But the attribute must be final or effectively final. \n\n\n\n\nRemember:\n\nA variable or parameter whose value is never changed after it is initialized is effectively final.\n\n\n\n\n\n  public void doSomethingWithOld(ByteArrayInputStream bais) throws Exception {\n    try(final ByteArrayInputStream stream = bais) {\n      final byte[] readAllBytes = stream.readAllBytes();\n    }\n  }  \n\n  public void doSomethingWith(ByteArrayInputStream bais) throws Exception {\n    try(bais) {\n      final byte[] readAllBytes = bais.readAllBytes();\n    }\n  }\n\n\n\n\nAllow diamond with anonymous classes if the argument type of the inferred type is denotable.\n\n\nThis is a small change for Generics. \n\n\n  //possible in Java8\n  public \nT\n MySimpleInterface\nT\n createInterface(T value) {\n    return () -\n value;\n  }\n\n  //NOT possible in Java8\n  public \nT\n MySimpleClass\nT\n create(T value) {\n    //return new MySimpleClass\nT\n() {\n    return new MySimpleClass\n() {\n      @Override\n      public T create() {\n        return value;\n      }\n    };\n  }\n\n\n  private static abstract class MySimpleClass\nT\n {\n    public abstract T create();\n  }\n\n  private interface MySimpleInterface\nT\n {\n    T create();\n  }\n\n\n\n\nUp to Java8 you could not use a Diamond Operator at the line defining the inner anonymous class.\nBut with Java9 the type could be found at this place, and you could use the Diamond Operator.\nBut if you are using a Functional Interface, this was \"possible\" at the place you define the lambda expression.\n\n\nComplete the removal, begun in Java SE 8, of underscore from the set of legal identifier names.\n\n\nThis is quite simple to explain. The identifier \"_\" is not allowed anymore. In combination with other letters yes, \nbut now as identifier alone.  \n\n\nSupport for private methods in interfaces\n\n\nNow we are able to provide private methods in interfaces. This private methods are accessible \ninside the interface, not in the implementing claas.\n\n\nThis will give you the possibility to give your default implementations a better structure compared to the \nJava8 version. \n\n\n@FunctionalInterface\npublic interface Service {\n\n  default void workOnDefault() {\n    workA();\n    workB();\n    workC();\n    //somethingHidden();\n  }\n\n  void workA();\n\n  private void workB() {\n    System.out.println(\nworkB = \n);\n  }\n\n  private static void workC() {\n    System.out.println(\nworkC \n);\n  }\n\n  //private void somethingHidden(); // declaration only not possible\n}\n\n\n\n\nHave in mind, that a private declaration without a method body is not allowed. May the IDE is not complaining.\nThe same with overriding the private method declaration. This will not used from the default implementation.\n\n\n    final Service service01 = new Service() {\n\n      @Override\n      public void workA() { }\n\n      private void workB() {\n        //super.workB(); not possible\n        // this implementation will not used from the default\n        System.out.println(\nservice01.workB() = \n);\n      }\n    };\n    service01.workOnDefault();\n\n\n\n\nOr as Lambda.\n\n\n((Service)() -\n { }).workOnDefault();", 
            "title": "JEP213"
        }, 
        {
            "location": "/JEP213/#milling-project-coin", 
            "text": "This  JEP  is flagged wit  tools\u2009/\u2009javac .  This JEP is divided in five parts. This is more or less a collections of improvements\nof things we got with Java7 and Java8.", 
            "title": "Milling Project Coin"
        }, 
        {
            "location": "/JEP213/#allow-safevargs-on-private-instance-methods", 
            "text": "The @SafeVarargs annotation can only be applied to methods which cannot be overridden, \nlike static final or public final methods.\nWith Java9 we could do this now with private methods, too.\nEven if they are (static/unstatic) final or not.    @SafeVarargs\n  public static  T  void myStaticMethod(T... args) {\n    // do something\n  }  \n\n  @SafeVarargs\n  public final  T  void myUnStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private final  T  void myPrivateUnStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private   T  void myPrivateUnFinalUnStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private static final  T  void myPrivateStaticMethod(T... args) {\n    // do something\n  }\n\n  @SafeVarargs\n  private  static  T  void myPrivateUnFinalStaticMethod(T... args) {\n    // do something\n  }", 
            "title": "Allow @SafeVargs on private instance methods."
        }, 
        {
            "location": "/JEP213/#allow-effectively-final-variables-to-be-used-as-resources-in-the-try-with-resources-statement", 
            "text": "The target here was the reduction of boilderplate code. In Java7 and Java8 you had to write the following\nlines to deal with an  AutoClosable    public void doSomethingWithOld(ByteArrayInputStream bais) throws Exception {\n    try(final ByteArrayInputStream stream = bais) {\n      final byte[] readAllBytes = stream.readAllBytes();\n    }\n  }    In Java9 you could write it without declaring a new variable. But the attribute must be final or effectively final.    Remember: \nA variable or parameter whose value is never changed after it is initialized is effectively final.   \n  public void doSomethingWithOld(ByteArrayInputStream bais) throws Exception {\n    try(final ByteArrayInputStream stream = bais) {\n      final byte[] readAllBytes = stream.readAllBytes();\n    }\n  }  \n\n  public void doSomethingWith(ByteArrayInputStream bais) throws Exception {\n    try(bais) {\n      final byte[] readAllBytes = bais.readAllBytes();\n    }\n  }", 
            "title": "Allow effectively-final variables to be used as resources in the try-with-resources statement."
        }, 
        {
            "location": "/JEP213/#allow-diamond-with-anonymous-classes-if-the-argument-type-of-the-inferred-type-is-denotable", 
            "text": "This is a small change for Generics.     //possible in Java8\n  public  T  MySimpleInterface T  createInterface(T value) {\n    return () -  value;\n  }\n\n  //NOT possible in Java8\n  public  T  MySimpleClass T  create(T value) {\n    //return new MySimpleClass T () {\n    return new MySimpleClass () {\n      @Override\n      public T create() {\n        return value;\n      }\n    };\n  }\n\n\n  private static abstract class MySimpleClass T  {\n    public abstract T create();\n  }\n\n  private interface MySimpleInterface T  {\n    T create();\n  }  Up to Java8 you could not use a Diamond Operator at the line defining the inner anonymous class.\nBut with Java9 the type could be found at this place, and you could use the Diamond Operator.\nBut if you are using a Functional Interface, this was \"possible\" at the place you define the lambda expression.", 
            "title": "Allow diamond with anonymous classes if the argument type of the inferred type is denotable."
        }, 
        {
            "location": "/JEP213/#complete-the-removal-begun-in-java-se-8-of-underscore-from-the-set-of-legal-identifier-names", 
            "text": "This is quite simple to explain. The identifier \"_\" is not allowed anymore. In combination with other letters yes, \nbut now as identifier alone.", 
            "title": "Complete the removal, begun in Java SE 8, of underscore from the set of legal identifier names."
        }, 
        {
            "location": "/JEP213/#support-for-private-methods-in-interfaces", 
            "text": "Now we are able to provide private methods in interfaces. This private methods are accessible \ninside the interface, not in the implementing claas.  This will give you the possibility to give your default implementations a better structure compared to the \nJava8 version.   @FunctionalInterface\npublic interface Service {\n\n  default void workOnDefault() {\n    workA();\n    workB();\n    workC();\n    //somethingHidden();\n  }\n\n  void workA();\n\n  private void workB() {\n    System.out.println( workB =  );\n  }\n\n  private static void workC() {\n    System.out.println( workC  );\n  }\n\n  //private void somethingHidden(); // declaration only not possible\n}  Have in mind, that a private declaration without a method body is not allowed. May the IDE is not complaining.\nThe same with overriding the private method declaration. This will not used from the default implementation.      final Service service01 = new Service() {\n\n      @Override\n      public void workA() { }\n\n      private void workB() {\n        //super.workB(); not possible\n        // this implementation will not used from the default\n        System.out.println( service01.workB() =  );\n      }\n    };\n    service01.workOnDefault();  Or as Lambda.  ((Service)() -  { }).workOnDefault();", 
            "title": "Support for private methods in interfaces"
        }, 
        {
            "location": "/JEP259/", 
            "text": "Stack-Walking API\n\n\nThis \nJEP\n is flagged wit \ncore\n.\n\n\nAll source codes I am using here you could find under \n\n\ngithub - java-9 / workshop_java09\n\n\nStackWalker\n\n\nThe StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few \ngetIntance(..)\n methods.\n\n\nFor this examples I created a class \nHolder\n to create a Stack you could walk through.\n\n\n public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println(\nend reached..\n);\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }\n\n\n\n\nWith this we are creating a well defined stack now.\n\n\n    new Holder(new Holder(new Holder(null) )).doWork();\n\n\n\n\nThe output here will be something like the following. Have in mind that I was starting this from inside IntelliJ\n\n\nend reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n\n\n\n\nmore detailed informations\n\n\nYou could get more informations out of the StackWalker as you saw before.\nFor this the class Holder will be extended now a little bit more.\n\n\n public static class Holder002 {\n    private Holder002 holder;\n\n    public Holder002(final Holder002 holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println(\nend reached..\n);\n        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n            .forEach(stackFrame -\n {\n              final int byteCodeIndex = stackFrame.getByteCodeIndex();\n              System.out.println(\nbyteCodeIndex = \n + byteCodeIndex);\n              // byteCode Index :\n              final String className = stackFrame.getClassName();\n              System.out.println(\nclassName = \n + className);\n              final Class\n?\n declaringClass = stackFrame.getDeclaringClass();\n              System.out.println(\ndeclaringClass = \n + declaringClass);\n              final String fileName = stackFrame.getFileName();\n              System.out.println(\nfileName = \n + fileName);\n              final int lineNumber = stackFrame.getLineNumber();\n              System.out.println(\nlineNumber = \n + lineNumber);\n              final String methodName = stackFrame.getMethodName();\n              System.out.println(\nmethodName = \n + methodName);\n            });\n      } else {\n        holder.doWork();\n      }\n    }\n  }\n\n\n\n\nHere we have to use the first time a defined \ngetInstance(..)\n method to get all informations. \nIf you are not using the right \nStackWalker.Option\n the result will be an exception.\nYou have three Options.\n\n\n\n\n\n\nRETAIN_CLASS_REFERENCE:\n getCallerClass() and getDeclaringClass() will work\n\n\n\n\n\n\nSHOW_REFLECT_FRAMES:\n This will show all reflections frames that are hidden by default\n\n\n\n\n\n\nSHOW_HIDDEN_FRAMES:\n This will show all reflection frames and additionally implementation specific internal frames\n\n\n\n\n\n\nTwo things are not used in this example.\nFirst is the method \nisNativeMethod()\n to identify if the caller method in the stack is a JVM native one \nand second \ntoStackTraceElement()\n to convert this information to a StackTraceElement that you \ncould use to generate a more detailed Exception-Message. \n\n\nSystem.out.println(\nend reached..\n);\n        final StackTraceElement[] stackTraceElements = StackWalker\n            .getInstance()\n            .walk(sfStream -\n sfStream\n                .takeWhile(frame -\n frame.getClassName().startsWith(\norg.rapidpm\n))\n                .collect(Collectors.toList()))\n            .stream()\n            .map(StackWalker.StackFrame::toStackTraceElement)\n            .toArray(StackTraceElement[]::new);\n\n        try {\n          final RuntimeException runtimeException = new RuntimeException();\n          runtimeException.setStackTrace(stackTraceElements);\n          throw runtimeException;\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n\n\n\n\nThe output on my machine was.\n\n\nend reached..\njava.lang.RuntimeException\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:41)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004.main(JEP259V004.java:26)\n\n\n\n\nfilter the stack\n\n\nSometime you will have to filter a few of this information out that is given by the StackWalker.\nFor this you can work with the stream as done before at other places. The method \nwalk(..)\n will \ngive you the possibility to add a Predicate that will be used to filter the result.\nHere I only want to have all elements from a specific namespace. \n(btw: the method ``takeWhile()```  is new too, check for this the section about Streams)\n\n\nStackWalker\n            .getInstance()\n            .walk(sfStream -\n sfStream\n                .takeWhile(frame -\n frame.getClassName().startsWith(\norg.rapidpm\n))\n                .collect(Collectors.toList()))\n            .forEach(System.out::println);\n\n\n\n\nsometimes you only want to know...\n\n\nYes, sometimes you only want to know the caller class. Don\u00b4t worry, there is a simple solution.\n\n\nfinal Class\n?\n callerClass = StackWalker\n        .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) //Option needed\n        .getCallerClass();\n    System.out.println(\ncallerClass = \n + callerClass);", 
            "title": "JEP259"
        }, 
        {
            "location": "/JEP259/#stack-walking-api", 
            "text": "This  JEP  is flagged wit  core .  All source codes I am using here you could find under   github - java-9 / workshop_java09", 
            "title": "Stack-Walking API"
        }, 
        {
            "location": "/JEP259/#stackwalker", 
            "text": "The StackWalker will give you the information about the caller tree of your ethod you are just in.\nTo get an instance of the StackWalcker you can use a few  getIntance(..)  methods.  For this examples I created a class  Holder  to create a Stack you could walk through.   public static class Holder {\n    private Holder holder;\n\n    public Holder(final Holder holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println( end reached.. );\n        StackWalker.getInstance().forEach(System.out::println);\n      } else {\n        holder.doWork();\n      }\n    }\n  }  With this we are creating a well defined stack now.      new Holder(new Holder(new Holder(null) )).doWork();  The output here will be something like the following. Have in mind that I was starting this from inside IntelliJ  end reached..\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:39)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001$Holder.doWork(JEP259V001.java:41)\norg.rapidpm.workshop.java09.jep259.JEP259V001.main(JEP259V001.java:25)\ncom.intellij.rt.execution.application.AppMain.main(AppMain.java:147)", 
            "title": "StackWalker"
        }, 
        {
            "location": "/JEP259/#more-detailed-informations", 
            "text": "You could get more informations out of the StackWalker as you saw before.\nFor this the class Holder will be extended now a little bit more.   public static class Holder002 {\n    private Holder002 holder;\n\n    public Holder002(final Holder002 holder) {\n      this.holder = holder;\n    }\n    public void doWork() {\n      if (Objects.isNull(holder)) {\n        System.out.println( end reached.. );\n        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n            .forEach(stackFrame -  {\n              final int byteCodeIndex = stackFrame.getByteCodeIndex();\n              System.out.println( byteCodeIndex =   + byteCodeIndex);\n              // byteCode Index :\n              final String className = stackFrame.getClassName();\n              System.out.println( className =   + className);\n              final Class ?  declaringClass = stackFrame.getDeclaringClass();\n              System.out.println( declaringClass =   + declaringClass);\n              final String fileName = stackFrame.getFileName();\n              System.out.println( fileName =   + fileName);\n              final int lineNumber = stackFrame.getLineNumber();\n              System.out.println( lineNumber =   + lineNumber);\n              final String methodName = stackFrame.getMethodName();\n              System.out.println( methodName =   + methodName);\n            });\n      } else {\n        holder.doWork();\n      }\n    }\n  }  Here we have to use the first time a defined  getInstance(..)  method to get all informations. \nIf you are not using the right  StackWalker.Option  the result will be an exception.\nYou have three Options.    RETAIN_CLASS_REFERENCE:  getCallerClass() and getDeclaringClass() will work    SHOW_REFLECT_FRAMES:  This will show all reflections frames that are hidden by default    SHOW_HIDDEN_FRAMES:  This will show all reflection frames and additionally implementation specific internal frames    Two things are not used in this example.\nFirst is the method  isNativeMethod()  to identify if the caller method in the stack is a JVM native one \nand second  toStackTraceElement()  to convert this information to a StackTraceElement that you \ncould use to generate a more detailed Exception-Message.   System.out.println( end reached.. );\n        final StackTraceElement[] stackTraceElements = StackWalker\n            .getInstance()\n            .walk(sfStream -  sfStream\n                .takeWhile(frame -  frame.getClassName().startsWith( org.rapidpm ))\n                .collect(Collectors.toList()))\n            .stream()\n            .map(StackWalker.StackFrame::toStackTraceElement)\n            .toArray(StackTraceElement[]::new);\n\n        try {\n          final RuntimeException runtimeException = new RuntimeException();\n          runtimeException.setStackTrace(stackTraceElements);\n          throw runtimeException;\n        } catch (Exception e) {\n          e.printStackTrace();\n        }  The output on my machine was.  end reached..\njava.lang.RuntimeException\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:41)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004$Holder001.doWork(JEP259V004.java:58)\n    at org.rapidpm.workshop.java09.jep259.JEP259V004.main(JEP259V004.java:26)", 
            "title": "more detailed informations"
        }, 
        {
            "location": "/JEP259/#filter-the-stack", 
            "text": "Sometime you will have to filter a few of this information out that is given by the StackWalker.\nFor this you can work with the stream as done before at other places. The method  walk(..)  will \ngive you the possibility to add a Predicate that will be used to filter the result.\nHere I only want to have all elements from a specific namespace. \n(btw: the method ``takeWhile()```  is new too, check for this the section about Streams)  StackWalker\n            .getInstance()\n            .walk(sfStream -  sfStream\n                .takeWhile(frame -  frame.getClassName().startsWith( org.rapidpm ))\n                .collect(Collectors.toList()))\n            .forEach(System.out::println);", 
            "title": "filter the stack"
        }, 
        {
            "location": "/JEP259/#sometimes-you-only-want-to-know", 
            "text": "Yes, sometimes you only want to know the caller class. Don\u00b4t worry, there is a simple solution.  final Class ?  callerClass = StackWalker\n        .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE) //Option needed\n        .getCallerClass();\n    System.out.println( callerClass =   + callerClass);", 
            "title": "sometimes you only want to know..."
        }, 
        {
            "location": "/JEP264/", 
            "text": "Platform Logging API and Service - LoggerFinder\n\n\nThis \nJEP\n is flagged with \ncore-util.logging\n.\n\n\nThe main thing of this JEP is providing a facade for logging. It is something like\nsl4j but now as part of the JDK.\n\n\nNow we have to give an answer to a few questions.\n\n\nHow to define a Logger?\n\n\nTo define a Logger by yourself, you could implement the interface \nSystem.Logger\n.\nWith this you could implement a Debugging-Logger for you project or delegate to the Implementation you want to use\nif there is nothing provided from the Logger-Framework itself.\n\n\npublic class SysOutLogger implements System.Logger {\n\n   @Override\n   public String getName() {\n     return SysOutLogger.class.getSimpleName();\n   }\n\n   @Override // this conf is useless ;-)\n   public boolean isLoggable(Level level) {\n     switch (level) {\n       case OFF: return false; \n       case TRACE: return false;\n       case DEBUG: return true;\n       case INFO: return true;\n       case WARNING: return false;\n       case ERROR: return false;\n       case ALL: return false;\n       default:\n         return true;\n     }\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n     System.out.printf(\nSysOutLogger: %s: \\\n%s\\\n with \\\n%s\\\n%n\n, level, msg, thrown);\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n     System.out.printf(\nSysOutLogger: %s: \\\n%s\\\n%n\n, level, format(format, params));\n   }\n }\n\n\n\n\nHow to declare this Logger so that it could be used?\n\n\nAfter this we have to make sure the system will use this one.\nFor this you have to extend the class \nSystem.LoggerFinder\n.\nHere you have to decide what will be the right Logger instance. This could be different in \nin different situations. You could use this for a more dynamic \nbehavior.\n\n\npublic class SysOutLoggerFinder extends System.LoggerFinder {\n\n  @Override\n  public System.Logger getLogger(String name, Module module) {\n    return new SysOutLogger();\n  }\n}\n\n\n\n\nSo far, so good..  but if you will try using it..  Nothing will happen.\nYou have to declare this as the active LoggingFinder.\nThe traditional way of doing it, would be a ServiceLocator. But with Java9 you could use\nthe file \nmodule-info.java\n\n\nmodule org.rapidpm.workshop.java09.jep264.v001.logger {\n  provides `\n      with org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder;\n}\n\n\n\n\nHere you could see, that the interface \njava.lang.System.LoggerFinder\n\nwill be connected with the implementation \norg.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder\n\n\nNow you could use it.\n\n\n    final System.Logger logger = System.getLogger(\nLoggerName\n);\n    System.out.println(logger.getName());\n    System.out.println(\nlogger = \n + logger);\n\n    final boolean loggable = logger.isLoggable(System.Logger.Level.DEBUG);\n    System.out.println(\nloggable = \n + loggable);\n\n    logger.log(System.Logger.Level.DEBUG, () -\n \nlogmessage\n);\n\n\n\n\n\nThe output would be something like the follwoing.\n\n\nSysOutLogger\nlogger = org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLogger@394e1a0f\nloggable = true\nSysOutLogger: x DEBUG: \nlogmessage\n\n\n\n\n\nwhy we want to use Supplier?\n\n\nLet\u00b4s asume we want to log the following statement.\n\n\nString message = \nhere \n + \nare \n + \nexpensive \n + \nops \n + methodToShowThePrice();\n\n  private static String methodToShowThePrice() {\n    System.out.println(\n will create instance now.....\n);\n    return LocalDateTime.now().toString();\n  }\n\n\n\n\nThe Logger-Interface provides a few method signatures for the method \nlog(..)\n\nThe simple one is expecting a String as argument.\n\n\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n\n\n\nThis means that you have to wrap the log-call into an if - statement to avoid useless\ncreations of the message String.\n\n\n    //log something\n    if(logger.isLoggable(System.Logger.Level.DEBUG)) \n      logger.log(System.Logger.Level.DEBUG, \nhere \n + \nare \n + \nexpensive \n + \nops \n + methodToShowThePrice());\n\n    // Logger not working on this level\n    if(logger.isLoggable(System.Logger.Level.TRACE))\n      logger.log(System.Logger.Level.TRACE, \nhere \n + \nare \n + \nexpensive \n + \nops \n + methodToShowThePrice());\n\n\n\n\nBut this could be written shorter if you are using Supplier.\nFirst check the implementation of the log - method that will accept Supplier instead of a String.\n\n\n        public default void log(Level level, Supplier\nString\n msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n\n\n\nHere you could see, that it will be checked if the logger is working with the given level.\nSo your code should look like one of the following lines..\n\n\n   // version one with on the fly Supplier\n   logger.log(System.Logger.Level.DEBUG, ()-\n \nhere \n + \nare \n + \nexpensive \n + \nops \n + methodToShowThePrice());\n\n  //version two with a global defined Supplier\n  private Supplier\nString\n logMessage = ()-\n \nhere \n + \nare \n + \nexpensive \n + \nops \n + methodToShowThePrice();\n\n  logger.log(System.Logger.Level.DEBUG, logMessage);\n\n\n\n\nHappy logging......", 
            "title": "JEP264"
        }, 
        {
            "location": "/JEP264/#platform-logging-api-and-service-loggerfinder", 
            "text": "This  JEP  is flagged with  core-util.logging .  The main thing of this JEP is providing a facade for logging. It is something like\nsl4j but now as part of the JDK.  Now we have to give an answer to a few questions.", 
            "title": "Platform Logging API and Service - LoggerFinder"
        }, 
        {
            "location": "/JEP264/#how-to-define-a-logger", 
            "text": "To define a Logger by yourself, you could implement the interface  System.Logger .\nWith this you could implement a Debugging-Logger for you project or delegate to the Implementation you want to use\nif there is nothing provided from the Logger-Framework itself.  public class SysOutLogger implements System.Logger {\n\n   @Override\n   public String getName() {\n     return SysOutLogger.class.getSimpleName();\n   }\n\n   @Override // this conf is useless ;-)\n   public boolean isLoggable(Level level) {\n     switch (level) {\n       case OFF: return false; \n       case TRACE: return false;\n       case DEBUG: return true;\n       case INFO: return true;\n       case WARNING: return false;\n       case ERROR: return false;\n       case ALL: return false;\n       default:\n         return true;\n     }\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) {\n     System.out.printf( SysOutLogger: %s: \\ %s\\  with \\ %s\\ %n , level, msg, thrown);\n   }\n\n   @Override\n   public void log(Level level, ResourceBundle bundle, String format, Object... params) {\n     System.out.printf( SysOutLogger: %s: \\ %s\\ %n , level, format(format, params));\n   }\n }", 
            "title": "How to define a Logger?"
        }, 
        {
            "location": "/JEP264/#how-to-declare-this-logger-so-that-it-could-be-used", 
            "text": "After this we have to make sure the system will use this one.\nFor this you have to extend the class  System.LoggerFinder .\nHere you have to decide what will be the right Logger instance. This could be different in \nin different situations. You could use this for a more dynamic \nbehavior.  public class SysOutLoggerFinder extends System.LoggerFinder {\n\n  @Override\n  public System.Logger getLogger(String name, Module module) {\n    return new SysOutLogger();\n  }\n}  So far, so good..  but if you will try using it..  Nothing will happen.\nYou have to declare this as the active LoggingFinder.\nThe traditional way of doing it, would be a ServiceLocator. But with Java9 you could use\nthe file  module-info.java  module org.rapidpm.workshop.java09.jep264.v001.logger {\n  provides `\n      with org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder;\n}  Here you could see, that the interface  java.lang.System.LoggerFinder \nwill be connected with the implementation  org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLoggerFinder  Now you could use it.      final System.Logger logger = System.getLogger( LoggerName );\n    System.out.println(logger.getName());\n    System.out.println( logger =   + logger);\n\n    final boolean loggable = logger.isLoggable(System.Logger.Level.DEBUG);\n    System.out.println( loggable =   + loggable);\n\n    logger.log(System.Logger.Level.DEBUG, () -   logmessage );  The output would be something like the follwoing.  SysOutLogger\nlogger = org.rapidpm.workshop.java09.jep264.v001.logger.SysOutLogger@394e1a0f\nloggable = true\nSysOutLogger: x DEBUG:  logmessage", 
            "title": "How to declare this Logger so that it could be used?"
        }, 
        {
            "location": "/JEP264/#why-we-want-to-use-supplier", 
            "text": "Let\u00b4s asume we want to log the following statement.  String message =  here   +  are   +  expensive   +  ops   + methodToShowThePrice();\n\n  private static String methodToShowThePrice() {\n    System.out.println(  will create instance now..... );\n    return LocalDateTime.now().toString();\n  }  The Logger-Interface provides a few method signatures for the method  log(..) \nThe simple one is expecting a String as argument.          public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }  This means that you have to wrap the log-call into an if - statement to avoid useless\ncreations of the message String.      //log something\n    if(logger.isLoggable(System.Logger.Level.DEBUG)) \n      logger.log(System.Logger.Level.DEBUG,  here   +  are   +  expensive   +  ops   + methodToShowThePrice());\n\n    // Logger not working on this level\n    if(logger.isLoggable(System.Logger.Level.TRACE))\n      logger.log(System.Logger.Level.TRACE,  here   +  are   +  expensive   +  ops   + methodToShowThePrice());  But this could be written shorter if you are using Supplier.\nFirst check the implementation of the log - method that will accept Supplier instead of a String.          public default void log(Level level, Supplier String  msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }  Here you could see, that it will be checked if the logger is working with the given level.\nSo your code should look like one of the following lines..     // version one with on the fly Supplier\n   logger.log(System.Logger.Level.DEBUG, ()-   here   +  are   +  expensive   +  ops   + methodToShowThePrice());\n\n  //version two with a global defined Supplier\n  private Supplier String  logMessage = ()-   here   +  are   +  expensive   +  ops   + methodToShowThePrice();\n\n  logger.log(System.Logger.Level.DEBUG, logMessage);  Happy logging......", 
            "title": "why we want to use Supplier?"
        }, 
        {
            "location": "/JEP266/", 
            "text": "More Concurrency Updates\n\n\nThis \nJEP\n is flagged with \ncore-util.concurrent\n.\n\n\nPublisher Subscriber\n\n\nOne subscriber with consume\n\n\nFor the beginning just create one Publisher and consume all messages.\nFor the Publisher we use the \nSubmissionPublisher\n provided by the Java API so we do not have to implement the Interface. \n The \nSubmissionPublisher\n implements \nAutoClosable\n so we can create it in a try with resources and do not have to bother closing it.\n\n\nWith the method \npublic CompletableFuture\nVoid\n consume(Consumer\n? super T\n consumer)\n\n we can add a Consumer. The Consumer interface is a functional interface so we can easily use lamdas to implement it. In return we get a \nCompletableFuture\nVoid\n which is done when the \nPublisher\n is closed. So we can wait for the completion with \nget()\n in the finally block of the try. So we can be sure that the work is done.\n\n\nNow we only need to add something to publish to the publisher. This is achieved with the \npublic int submit(T item)\n method of the \nSubmissionPublisher\n.\n An example of this will look like this:\n\n\npublic class JEP266v001 {\n  public static void main(String[] args) throws InterruptedException, ExecutionException {\n    CompletableFuture consume = null;\n    try (SubmissionPublisher pup = new SubmissionPublisher\nString\n()) {\n      consume = pup.consume(System.out::println);\n      IntStream.range(1, 10).forEach(pup::submit);\n    } finally {\n      consume.get();\n    }\n  }\n}\n\n\n\n\n\nThe output of this code looks like this:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\nProcess finished with exit code 0\n\n\n\n\nSo all messages where published and printed to stdout.\n\n\nWriting your own subscriber\n\n\nTo write your own subscriber you need to implement the interface \npublic static interface Subscriber\nT\n in the class \nFlow\n. For this example lets write a Subscriber which greets the messages on stdout. The Greeter shall have a name so we can identify the subscriber if we add multiple instances to one publisher.\n\n\n  public static class GreetingSubscriber implements Flow.Subscriber\nString\n {\n\n    private final String name;\n    private Flow.Subscription subscription;\n\n    public GreetingSubscriber(String name) {\n      this.name = name;\n    }\n\n    @Override\n    public void onSubscribe(Flow.Subscription subscription) {\n      this.subscription = subscription;\n      subscription.request(1);\n    }\n\n\n    @Override\n    public void onNext(String item) {\n      subscription.request(1);\n      System.out.println(String.format(\n%s says: Hello %s\n, name, item));\n      System.out.flush();\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n      System.err.print(throwable);\n    }\n\n    @Override\n    public void onComplete() {\n      // nothing to do here\n    }\n  }\n\n\n\n\nThe method \npublic void onSubscribe(Flow.Subscription subscription)\n is called when a subscriber subscribes to a publisher. We will get a \nSubscription\n object which represents the connection with the publisher. When we subscribe we have to request a number of messages we want to process. This is done via the \npublic void request(long n)\n method of the \nSubscription\n. For this example we will request only one message at a time so wi call: \n\n\nsubscription.request(1);\n\n\n\n\nIf we want to get an unbound amount of messages we would have to call: \n\n\nsubscription.request(Long.MAX_VALUE);\n\n\n\n\nBut because we only have requested one message we need to request additiional messages when we process a message. Therefor we store the \nSubscription\n in a member variable.\n\n\nThe the work is done in the \npublic void onNext(T item)\n method. In this method we greet the message and request a new one.\n\n\n@Override\n    public void onNext(String item) {\n      subscription.request(1);\n      System.out.println(String.format(\n%s says: Hello %s\n, name, item));\n      System.out.flush();\n    }\n\n\n\n\nNow we have a working subscriber lets add it to a publisher.\n\n\n public static void main(String[] args) throws InterruptedException {\n\n    try (SubmissionPublisher pup = new SubmissionPublisher\nString\n()) {\n\n      pup.subscribe(new GreetingSubscriber(\nSub1\n));\n\n      IntStream.range(1, 10)\n              .boxed()\n              .map(String::valueOf)\n              .forEach(pup::submit);\n\n      System.out.println(\npublished all the numbers\n);\n      Thread.sleep(100 + pup.estimateMaximumLag());\n    }\n  }\n\n\n\n\nWe start like before and create a \nSubmissionPublisher\n in a try with resource.\nThen we subscribe our subscriber to the publisher with  \npup.subscribe(new GreetingSubscriber(\"Sub1\"));\n. Then we add messages to the publisher. But this time we do not get  future to wait for. If we would run the code without a sleep we would only see that we published all numbers but potentially no greeting.\n\n\npublished all the numbers\n\nProcess finished with exit code 0\n\n\n\n\nTo let the subscribers do work they need time. So lets put the main thread to sleep.\n\nThread.sleep(100 + pup.estimateMaximumLag());\n\nThe publisher can give us a estimation on how much lag there most likely will be. We add a little bit of extra time and now we should see the greetings.\n\n\npublished all the numbers\nSub1 says: Hello 1\nSub1 says: Hello 2\nSub1 says: Hello 3\nSub1 says: Hello 4\nSub1 says: Hello 5\nSub1 says: Hello 6\nSub1 says: Hello 7\nSub1 says: Hello 8\nSub1 says: Hello 9\n\nProcess finished with exit code 0\n\n\n\n\nAdding a second subscriber\n\n\nWe can add a second subscriber to the same publisher.\n\n\n public static void main(String[] args) throws InterruptedException {\n\n    try (SubmissionPublisher pup = new SubmissionPublisher\nString\n()) {\n\n      pup.subscribe(new GreetingSubscriber(\nSub1\n));\n      pup.subscribe(new GreetingSubscriber(\nSub2\n));\n\n      IntStream.range(1, 10)\n              .boxed()\n              .map(String::valueOf)\n              .forEach(pup::submit);\n\n      System.out.println(\npublished all the numbers\n);\n      Thread.sleep(100 + pup.estimateMaximumLag());\n    }\n  }\n\n\n\n\nIf we run this we see an output like this:\n\n\npublished all the numbers\nSub1 says: Hello 1\nSub2 says: Hello 1\nSub2 says: Hello 2\nSub2 says: Hello 3\nSub2 says: Hello 4\nSub2 says: Hello 5\nSub2 says: Hello 6\nSub2 says: Hello 7\nSub2 says: Hello 8\nSub2 says: Hello 9\nSub1 says: Hello 2\nSub1 says: Hello 3\nSub1 says: Hello 4\nSub1 says: Hello 5\nSub1 says: Hello 6\nSub1 says: Hello 7\nSub1 says: Hello 8\nSub1 says: Hello 9\n\nProcess finished with exit code 0\n\n\n\n\n\nNote that the subscribers are not handled in order.\n\n\nAdding a processor\n\n\nA processor is a subscriber and a supplier in one class. It can be used to process messages e.g. convert them from one type to another.\n\n\nTo write a processor we extend the \nSubmissionPublisher\nTO\n with the type after the conversion and implement \nFlow.Processor\nFROM, TO\n  with \nTO\n being the same type as in the publisher and \nFROM\n being the type we receive. \n\n\nFor this example if we want to convert an \nInteger\n to a \nString\n the class has to look something like this.\n\n\n public static class IntToStringProcessor \n                      extends SubmissionPublisher\nString\n \n                      implements Flow.Processor\nInteger, String\n\n\n\n\n\nBecause we are a \nSubscriber\n we need to implement the method \nonSubscribe\n. We do this like we did in the subscribers before:\n\n\n    @Override\n      public void onSubscribe(Flow.Subscription subscription) {\n        this.subscription = subscription;\n        this.subscription.request(1);\n      }\n\n\n\n\nWe store the subscription in a member and request one message.\n Then we need to implement the \nonNext\n method. \n\n\n    @Override\n    public void onNext(Integer item) {\n      submit(String.valueOf(item));\n      subscription.request(1);\n    }\n\n\n\n\nWe recieve one Integer as message, convert it to a String and then submit the String. The \nsubmit\n method is provided by the \nSubmissionPublisher\n we extend.\nAfter submitting the message our work is done and we request another message.\nThe whole class looks something like this:\n\n\n  public static class IntToStringProcessor extends SubmissionPublisher\nString\n implements Flow.Processor\nInteger, String\n {\n\n    private Flow.Subscription subscription;\n\n    @Override\n    public void onSubscribe(Flow.Subscription subscription) {\n      this.subscription = subscription;\n      this.subscription.request(1);\n    }\n\n    @Override\n    public void onNext(Integer item) {\n      submit(String.valueOf(item));\n      subscription.request(1);\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n\n    }\n\n    @Override\n    public void onComplete() {\n\n    }\n  }\n\n\n\n\nNow we can bind our processor into our workflow. This is done by subscribing to the publisher. The subscriber on the other hand subscribes to the processor.\n\n\n public static void main(String[] args) throws InterruptedException {\n\n    try (SubmissionPublisher pup = new SubmissionPublisher\nInteger\n()) {\n\n      IntToStringProcessor processor = new IntToStringProcessor();\n      pup.subscribe(processor);\n      processor.subscribe(new TestSubscriber(\nSub1\n));\n\n      IntStream.range(1, 10)\n              .forEach(pup::submit);\n\n      System.out.println(\npublished all the numbers\n);\n      Thread.sleep(100 + pup.estimateMaximumLag());\n    }\n  }\n\n\n\n\nThis time we do not convert the \nIntStream\n, we let our processor do the work.\nThe output of this code looks like this:\n\n\npublished all the numbers\nSub1 says: Hello 1\nSub1 says: Hello 2\nSub1 says: Hello 3\nSub1 says: Hello 4\nSub1 says: Hello 5\nSub1 says: Hello 6\nSub1 says: Hello 7\nSub1 says: Hello 8\nSub1 says: Hello 9\n\nProcess finished with exit code 0\n\n\n\n\njava.util.concurrent.CompletableFuture improvements in Java9\n\n\npublic Executor defaultExecutor()\n\n\npublic CompletableFuture\n completeAsync(Supplier\n? extends T\n supplier, Executor executor)\n\n\npublic CompletableFuture\n completeAsync(Supplier\n? extends T\n supplier)\n\n\npublic \n CompletableFuture\n newIncompleteFuture()\n\n\npublic CompletionStage\n minimalCompletionStage()\n\n\npublic CompletableFuture\n orTimeout(long timeout, TimeUnit unit)\n\n\npublic CompletableFuture\n completeOnTimeout(T value, long timeout, TimeUnit unit)\n\n\npublic static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)\n\n\npublic static Executor delayedExecutor(long delay, TimeUnit unit)\n\n\npublic static \n CompletionStage\n completedStage(U value)\n\n\npublic static \n CompletableFuture\n failedFuture(Throwable ex)\n\n\npublic static \n CompletionStage\n failedStage(Throwable ex)", 
            "title": "JEP266"
        }, 
        {
            "location": "/JEP266/#more-concurrency-updates", 
            "text": "This  JEP  is flagged with  core-util.concurrent .", 
            "title": "More Concurrency Updates"
        }, 
        {
            "location": "/JEP266/#publisher-subscriber", 
            "text": "", 
            "title": "Publisher Subscriber"
        }, 
        {
            "location": "/JEP266/#one-subscriber-with-consume", 
            "text": "For the beginning just create one Publisher and consume all messages.\nFor the Publisher we use the  SubmissionPublisher  provided by the Java API so we do not have to implement the Interface. \n The  SubmissionPublisher  implements  AutoClosable  so we can create it in a try with resources and do not have to bother closing it.  With the method  public CompletableFuture Void  consume(Consumer ? super T  consumer) \n we can add a Consumer. The Consumer interface is a functional interface so we can easily use lamdas to implement it. In return we get a  CompletableFuture Void  which is done when the  Publisher  is closed. So we can wait for the completion with  get()  in the finally block of the try. So we can be sure that the work is done.  Now we only need to add something to publish to the publisher. This is achieved with the  public int submit(T item)  method of the  SubmissionPublisher .\n An example of this will look like this:  public class JEP266v001 {\n  public static void main(String[] args) throws InterruptedException, ExecutionException {\n    CompletableFuture consume = null;\n    try (SubmissionPublisher pup = new SubmissionPublisher String ()) {\n      consume = pup.consume(System.out::println);\n      IntStream.range(1, 10).forEach(pup::submit);\n    } finally {\n      consume.get();\n    }\n  }\n}  The output of this code looks like this:  1\n2\n3\n4\n5\n6\n7\n8\n9\n\nProcess finished with exit code 0  So all messages where published and printed to stdout.", 
            "title": "One subscriber with consume"
        }, 
        {
            "location": "/JEP266/#writing-your-own-subscriber", 
            "text": "To write your own subscriber you need to implement the interface  public static interface Subscriber T  in the class  Flow . For this example lets write a Subscriber which greets the messages on stdout. The Greeter shall have a name so we can identify the subscriber if we add multiple instances to one publisher.    public static class GreetingSubscriber implements Flow.Subscriber String  {\n\n    private final String name;\n    private Flow.Subscription subscription;\n\n    public GreetingSubscriber(String name) {\n      this.name = name;\n    }\n\n    @Override\n    public void onSubscribe(Flow.Subscription subscription) {\n      this.subscription = subscription;\n      subscription.request(1);\n    }\n\n\n    @Override\n    public void onNext(String item) {\n      subscription.request(1);\n      System.out.println(String.format( %s says: Hello %s , name, item));\n      System.out.flush();\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n      System.err.print(throwable);\n    }\n\n    @Override\n    public void onComplete() {\n      // nothing to do here\n    }\n  }  The method  public void onSubscribe(Flow.Subscription subscription)  is called when a subscriber subscribes to a publisher. We will get a  Subscription  object which represents the connection with the publisher. When we subscribe we have to request a number of messages we want to process. This is done via the  public void request(long n)  method of the  Subscription . For this example we will request only one message at a time so wi call:   subscription.request(1);  If we want to get an unbound amount of messages we would have to call:   subscription.request(Long.MAX_VALUE);  But because we only have requested one message we need to request additiional messages when we process a message. Therefor we store the  Subscription  in a member variable.  The the work is done in the  public void onNext(T item)  method. In this method we greet the message and request a new one.  @Override\n    public void onNext(String item) {\n      subscription.request(1);\n      System.out.println(String.format( %s says: Hello %s , name, item));\n      System.out.flush();\n    }  Now we have a working subscriber lets add it to a publisher.   public static void main(String[] args) throws InterruptedException {\n\n    try (SubmissionPublisher pup = new SubmissionPublisher String ()) {\n\n      pup.subscribe(new GreetingSubscriber( Sub1 ));\n\n      IntStream.range(1, 10)\n              .boxed()\n              .map(String::valueOf)\n              .forEach(pup::submit);\n\n      System.out.println( published all the numbers );\n      Thread.sleep(100 + pup.estimateMaximumLag());\n    }\n  }  We start like before and create a  SubmissionPublisher  in a try with resource.\nThen we subscribe our subscriber to the publisher with   pup.subscribe(new GreetingSubscriber(\"Sub1\")); . Then we add messages to the publisher. But this time we do not get  future to wait for. If we would run the code without a sleep we would only see that we published all numbers but potentially no greeting.  published all the numbers\n\nProcess finished with exit code 0  To let the subscribers do work they need time. So lets put the main thread to sleep. Thread.sleep(100 + pup.estimateMaximumLag()); \nThe publisher can give us a estimation on how much lag there most likely will be. We add a little bit of extra time and now we should see the greetings.  published all the numbers\nSub1 says: Hello 1\nSub1 says: Hello 2\nSub1 says: Hello 3\nSub1 says: Hello 4\nSub1 says: Hello 5\nSub1 says: Hello 6\nSub1 says: Hello 7\nSub1 says: Hello 8\nSub1 says: Hello 9\n\nProcess finished with exit code 0", 
            "title": "Writing your own subscriber"
        }, 
        {
            "location": "/JEP266/#adding-a-second-subscriber", 
            "text": "We can add a second subscriber to the same publisher.   public static void main(String[] args) throws InterruptedException {\n\n    try (SubmissionPublisher pup = new SubmissionPublisher String ()) {\n\n      pup.subscribe(new GreetingSubscriber( Sub1 ));\n      pup.subscribe(new GreetingSubscriber( Sub2 ));\n\n      IntStream.range(1, 10)\n              .boxed()\n              .map(String::valueOf)\n              .forEach(pup::submit);\n\n      System.out.println( published all the numbers );\n      Thread.sleep(100 + pup.estimateMaximumLag());\n    }\n  }  If we run this we see an output like this:  published all the numbers\nSub1 says: Hello 1\nSub2 says: Hello 1\nSub2 says: Hello 2\nSub2 says: Hello 3\nSub2 says: Hello 4\nSub2 says: Hello 5\nSub2 says: Hello 6\nSub2 says: Hello 7\nSub2 says: Hello 8\nSub2 says: Hello 9\nSub1 says: Hello 2\nSub1 says: Hello 3\nSub1 says: Hello 4\nSub1 says: Hello 5\nSub1 says: Hello 6\nSub1 says: Hello 7\nSub1 says: Hello 8\nSub1 says: Hello 9\n\nProcess finished with exit code 0  Note that the subscribers are not handled in order.", 
            "title": "Adding a second subscriber"
        }, 
        {
            "location": "/JEP266/#adding-a-processor", 
            "text": "A processor is a subscriber and a supplier in one class. It can be used to process messages e.g. convert them from one type to another.  To write a processor we extend the  SubmissionPublisher TO  with the type after the conversion and implement  Flow.Processor FROM, TO   with  TO  being the same type as in the publisher and  FROM  being the type we receive.   For this example if we want to convert an  Integer  to a  String  the class has to look something like this.   public static class IntToStringProcessor \n                      extends SubmissionPublisher String  \n                      implements Flow.Processor Integer, String   Because we are a  Subscriber  we need to implement the method  onSubscribe . We do this like we did in the subscribers before:      @Override\n      public void onSubscribe(Flow.Subscription subscription) {\n        this.subscription = subscription;\n        this.subscription.request(1);\n      }  We store the subscription in a member and request one message.\n Then we need to implement the  onNext  method.       @Override\n    public void onNext(Integer item) {\n      submit(String.valueOf(item));\n      subscription.request(1);\n    }  We recieve one Integer as message, convert it to a String and then submit the String. The  submit  method is provided by the  SubmissionPublisher  we extend.\nAfter submitting the message our work is done and we request another message.\nThe whole class looks something like this:    public static class IntToStringProcessor extends SubmissionPublisher String  implements Flow.Processor Integer, String  {\n\n    private Flow.Subscription subscription;\n\n    @Override\n    public void onSubscribe(Flow.Subscription subscription) {\n      this.subscription = subscription;\n      this.subscription.request(1);\n    }\n\n    @Override\n    public void onNext(Integer item) {\n      submit(String.valueOf(item));\n      subscription.request(1);\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n\n    }\n\n    @Override\n    public void onComplete() {\n\n    }\n  }  Now we can bind our processor into our workflow. This is done by subscribing to the publisher. The subscriber on the other hand subscribes to the processor.   public static void main(String[] args) throws InterruptedException {\n\n    try (SubmissionPublisher pup = new SubmissionPublisher Integer ()) {\n\n      IntToStringProcessor processor = new IntToStringProcessor();\n      pup.subscribe(processor);\n      processor.subscribe(new TestSubscriber( Sub1 ));\n\n      IntStream.range(1, 10)\n              .forEach(pup::submit);\n\n      System.out.println( published all the numbers );\n      Thread.sleep(100 + pup.estimateMaximumLag());\n    }\n  }  This time we do not convert the  IntStream , we let our processor do the work.\nThe output of this code looks like this:  published all the numbers\nSub1 says: Hello 1\nSub1 says: Hello 2\nSub1 says: Hello 3\nSub1 says: Hello 4\nSub1 says: Hello 5\nSub1 says: Hello 6\nSub1 says: Hello 7\nSub1 says: Hello 8\nSub1 says: Hello 9\n\nProcess finished with exit code 0", 
            "title": "Adding a processor"
        }, 
        {
            "location": "/JEP266/#javautilconcurrentcompletablefuture-improvements-in-java9", 
            "text": "", 
            "title": "java.util.concurrent.CompletableFuture improvements in Java9"
        }, 
        {
            "location": "/JEP266/#public-executor-defaultexecutor", 
            "text": "", 
            "title": "public Executor defaultExecutor()"
        }, 
        {
            "location": "/JEP266/#public-completablefuture-completeasyncsupplier-extends-t-supplier-executor-executor", 
            "text": "", 
            "title": "public CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)"
        }, 
        {
            "location": "/JEP266/#public-completablefuture-completeasyncsupplier-extends-t-supplier", 
            "text": "", 
            "title": "public CompletableFuture completeAsync(Supplier&lt;? extends T&gt; supplier)"
        }, 
        {
            "location": "/JEP266/#public-completablefuture-newincompletefuture", 
            "text": "", 
            "title": "public  CompletableFuture newIncompleteFuture()"
        }, 
        {
            "location": "/JEP266/#public-completionstage-minimalcompletionstage", 
            "text": "", 
            "title": "public CompletionStage minimalCompletionStage()"
        }, 
        {
            "location": "/JEP266/#public-completablefuture-ortimeoutlong-timeout-timeunit-unit", 
            "text": "", 
            "title": "public CompletableFuture orTimeout(long timeout, TimeUnit unit)"
        }, 
        {
            "location": "/JEP266/#public-completablefuture-completeontimeoutt-value-long-timeout-timeunit-unit", 
            "text": "", 
            "title": "public CompletableFuture completeOnTimeout(T value, long timeout, TimeUnit unit)"
        }, 
        {
            "location": "/JEP266/#public-static-executor-delayedexecutorlong-delay-timeunit-unit-executor-executor", 
            "text": "", 
            "title": "public static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)"
        }, 
        {
            "location": "/JEP266/#public-static-executor-delayedexecutorlong-delay-timeunit-unit", 
            "text": "", 
            "title": "public static Executor delayedExecutor(long delay, TimeUnit unit)"
        }, 
        {
            "location": "/JEP266/#public-static-completionstage-completedstageu-value", 
            "text": "", 
            "title": "public static  CompletionStage completedStage(U value)"
        }, 
        {
            "location": "/JEP266/#public-static-completablefuture-failedfuturethrowable-ex", 
            "text": "", 
            "title": "public static  CompletableFuture failedFuture(Throwable ex)"
        }, 
        {
            "location": "/JEP266/#public-static-completionstage-failedstagethrowable-ex", 
            "text": "", 
            "title": "public static  CompletionStage failedStage(Throwable ex)"
        }, 
        {
            "location": "/JEP269/", 
            "text": "Convenience Factory Methods for Collections\n\n\nThis \nJEP\n is flagged with \ncore-util:collections\n.\n\n\nThis JEP defines a few methods for \nSet\n , \nList\n and \nMap\n.\nAll methods returning immutable instances. \n\n\nSet and List\n\n\nThe classes \nSet\n and \nList\n got only the \nof(..)\n method to create \nan immutable instance with the given elements. All operations to modify the instance will lead to an \n\nUnsupportedOperationException\n\n\n    final Set\nObject\n of = Set.of(); //Returns an immutable set containing zero elements\n    of.add(new Object()); // will throw java.lang.UnsupportedOperationException\n\n    final boolean addB = Set.of(\nA\n).add(\nB\n);      // will throw java.lang.UnsupportedOperationException\n    final boolean addC = Set.of(\nA\n, \nB\n).add(\nC\n); // will throw java.lang.UnsupportedOperationException    \n\n\n\n\nMap\n\n\nFor the \nMap\n we got the \nof()\n methods, too. But here always with key/value pairs.\nThe difference to the \nSet\n and \nList\n is the possibility to create entries.\nBut here the same again, the instance is immutable.\n\n\n    final Map\nString, String\n keyA = Map.of(\nkeyA\n, \nvalueA\n);\n\n    // will creae an immutable Entry\n    final Map.Entry\nString, String\n entry = Map.entry(\nkeyA\n, \nvalueA\n);\n\n    final Map\nString, String\n map = Map.ofEntries(entry);\n\n\n\n\n\nNull\n\n\nOnly one more thing... you can not create Collections containing a \nnull\n.\nThe following line of code will produce a NPE.\n\n\nfinal Set\nString\n a = Set.of(\nA\n, null, \nB\n);", 
            "title": "JEP269"
        }, 
        {
            "location": "/JEP269/#convenience-factory-methods-for-collections", 
            "text": "This  JEP  is flagged with  core-util:collections .  This JEP defines a few methods for  Set  ,  List  and  Map .\nAll methods returning immutable instances.", 
            "title": "Convenience Factory Methods for Collections"
        }, 
        {
            "location": "/JEP269/#set-and-list", 
            "text": "The classes  Set  and  List  got only the  of(..)  method to create \nan immutable instance with the given elements. All operations to modify the instance will lead to an  UnsupportedOperationException      final Set Object  of = Set.of(); //Returns an immutable set containing zero elements\n    of.add(new Object()); // will throw java.lang.UnsupportedOperationException\n\n    final boolean addB = Set.of( A ).add( B );      // will throw java.lang.UnsupportedOperationException\n    final boolean addC = Set.of( A ,  B ).add( C ); // will throw java.lang.UnsupportedOperationException", 
            "title": "Set and List"
        }, 
        {
            "location": "/JEP269/#map", 
            "text": "For the  Map  we got the  of()  methods, too. But here always with key/value pairs.\nThe difference to the  Set  and  List  is the possibility to create entries.\nBut here the same again, the instance is immutable.      final Map String, String  keyA = Map.of( keyA ,  valueA );\n\n    // will creae an immutable Entry\n    final Map.Entry String, String  entry = Map.entry( keyA ,  valueA );\n\n    final Map String, String  map = Map.ofEntries(entry);", 
            "title": "Map"
        }, 
        {
            "location": "/JEP269/#null", 
            "text": "Only one more thing... you can not create Collections containing a  null .\nThe following line of code will produce a NPE.  final Set String  a = Set.of( A , null,  B );", 
            "title": "Null"
        }, 
        {
            "location": "/java.lang/StackTraceElement/", 
            "text": "New Methods in java.lang.StackTraceElement\n\n\nThe class itself is inside the JDK since 1.4.\n\n\nThe StackTraceElement will now have the information about the module and module-version.\nFor this they added a new constructor \n\n\npublic StackTraceElement(String moduleName, \n                         String moduleVersion,\n                         String declaringClass, \n                         String methodName,String \n                         fileName, int lineNumber)\n\n\n\n\nand the new getter methods \npublic String getModuleName()\n and \npublic String getModuleVersion()\n\n\nIf you want to try this, play with the following.\n\n\npublic static void main(String[] args) {\n    try {\n      throw new RuntimeException(\nand go\n);\n    } catch (Exception e) {\n      final StackTraceElement[] stackTrace = e.getStackTrace();\n      for (StackTraceElement stackTraceElement : stackTrace) {\n        final String moduleName = stackTraceElement.getModuleName();\n        final String moduleVersion = stackTraceElement.getModuleVersion();\n        System.out.println(\nmoduleVersion = \n + moduleVersion);\n        System.out.println(\nmoduleName = \n + moduleName);\n        System.out.println(stackTraceElement.getClassName() + \n - \n + stackTraceElement.getMethodName());\n      }\n    }\n  }\n\n\n\n\nThe output at may machine was the following.\n\n\nmoduleVersion = null\nmoduleName = null\norg.rapidpm.workshop.java09.java.lang.StackTraceElementV001 - main\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke0\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.DelegatingMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njava.lang.reflect.Method - invoke\nmoduleVersion = null\nmoduleName = null\ncom.intellij.rt.execution.application.AppMain - main\n\n\n\n\nThe interesting thing here is, that the first and the last triple is without \na module -version and -name.\n\n\nTry to find out, why ;-)", 
            "title": "StackTraceElement"
        }, 
        {
            "location": "/java.lang/StackTraceElement/#new-methods-in-javalangstacktraceelement", 
            "text": "The class itself is inside the JDK since 1.4.  The StackTraceElement will now have the information about the module and module-version.\nFor this they added a new constructor   public StackTraceElement(String moduleName, \n                         String moduleVersion,\n                         String declaringClass, \n                         String methodName,String \n                         fileName, int lineNumber)  and the new getter methods  public String getModuleName()  and  public String getModuleVersion()  If you want to try this, play with the following.  public static void main(String[] args) {\n    try {\n      throw new RuntimeException( and go );\n    } catch (Exception e) {\n      final StackTraceElement[] stackTrace = e.getStackTrace();\n      for (StackTraceElement stackTraceElement : stackTrace) {\n        final String moduleName = stackTraceElement.getModuleName();\n        final String moduleVersion = stackTraceElement.getModuleVersion();\n        System.out.println( moduleVersion =   + moduleVersion);\n        System.out.println( moduleName =   + moduleName);\n        System.out.println(stackTraceElement.getClassName() +   -   + stackTraceElement.getMethodName());\n      }\n    }\n  }  The output at may machine was the following.  moduleVersion = null\nmoduleName = null\norg.rapidpm.workshop.java09.java.lang.StackTraceElementV001 - main\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke0\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.NativeMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njdk.internal.reflect.DelegatingMethodAccessorImpl - invoke\nmoduleVersion = 9-ea\nmoduleName = java.base\njava.lang.reflect.Method - invoke\nmoduleVersion = null\nmoduleName = null\ncom.intellij.rt.execution.application.AppMain - main  The interesting thing here is, that the first and the last triple is without \na module -version and -name.  Try to find out, why ;-)", 
            "title": "New Methods in java.lang.StackTraceElement"
        }, 
        {
            "location": "/java.lang/StrictMath/", 
            "text": "New Methods in java.lang.StrictMath\n\n\nThe class itself is inside the JDK since 1.3.\n\n\npublic static long multiplyExact(long x, int y)\n\n\npublic static long multiplyFull(int x, int y)\n\n\npublic static long multiplyHigh(long x, long y)\n\n\npublic static long floorDiv(long x, int y)\n\n\npublic static int floorMod(long x, int y)\n\n\npublic static double fma(double a, double b, double c)\n\n\npublic static float fma(float a, float b, float c)", 
            "title": "StrictMath"
        }, 
        {
            "location": "/java.lang/StrictMath/#new-methods-in-javalangstrictmath", 
            "text": "The class itself is inside the JDK since 1.3.", 
            "title": "New Methods in java.lang.StrictMath"
        }, 
        {
            "location": "/java.lang/StrictMath/#public-static-long-multiplyexactlong-x-int-y", 
            "text": "", 
            "title": "public static long multiplyExact(long x, int y)"
        }, 
        {
            "location": "/java.lang/StrictMath/#public-static-long-multiplyfullint-x-int-y", 
            "text": "", 
            "title": "public static long multiplyFull(int x, int y)"
        }, 
        {
            "location": "/java.lang/StrictMath/#public-static-long-multiplyhighlong-x-long-y", 
            "text": "", 
            "title": "public static long multiplyHigh(long x, long y)"
        }, 
        {
            "location": "/java.lang/StrictMath/#public-static-long-floordivlong-x-int-y", 
            "text": "", 
            "title": "public static long floorDiv(long x, int y)"
        }, 
        {
            "location": "/java.lang/StrictMath/#public-static-int-floormodlong-x-int-y", 
            "text": "", 
            "title": "public static int floorMod(long x, int y)"
        }, 
        {
            "location": "/java.lang/StrictMath/#public-static-double-fmadouble-a-double-b-double-c", 
            "text": "", 
            "title": "public static double fma(double a, double b, double c)"
        }, 
        {
            "location": "/java.lang/StrictMath/#public-static-float-fmafloat-a-float-b-float-c", 
            "text": "", 
            "title": "public static float fma(float a, float b, float c)"
        }, 
        {
            "location": "/java.util/Optional/", 
            "text": "New Methods inside the class Optional\n\n\npublic Stream\n stream()\n\n\nIn Java8, if a method wrapped a result into an Optional, you had to make sure to test with \nisPresent\n \nif a value was wrapped. After this you could map it to the value itself. The new Method \nstream\n will \ncreate a Stream with one value if the value is present. If no value is present it will create an emtpy Stream.\n\n\nWith this you could combine the two steps ( \nfilter\n and \nmap\n ) to  one \nflatMap\n\n\n    final Function\nInteger, Optional\nInteger\n function\n        = (value) -\n (value \n= 4) ? Optional.of(value) : Optional.empty();\n\n    final List\nInteger\n collectionJava8 = Stream\n        .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        .map(function) // only to wrap\n        .filter(Optional::isPresent)\n        .map(Optional::get)\n        .collect(Collectors.toList());\n\n    final List\nInteger\n collectionJava9 = Stream\n        .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        .map(function) // only to wrap\n        .flatMap(Optional::stream)\n        .collect(Collectors.toList());\n\n    System.out.println(\ncollectionJava8 = \n + collectionJava8);\n    System.out.println(\ncollectionJava9 = \n + collectionJava9);\n\n\n\n\n\npublic Optional\n or(Supplier\n? extends Optional\n? extends T\n supplier)\n\n\nIn Java8  \n\n\npublic void ifPresentOrElse(Consumer\n? super T\n action, Runnable emptyAction)", 
            "title": "Optional"
        }, 
        {
            "location": "/java.util/Optional/#new-methods-inside-the-class-optional", 
            "text": "", 
            "title": "New Methods inside the class Optional"
        }, 
        {
            "location": "/java.util/Optional/#public-stream-stream", 
            "text": "In Java8, if a method wrapped a result into an Optional, you had to make sure to test with  isPresent  \nif a value was wrapped. After this you could map it to the value itself. The new Method  stream  will \ncreate a Stream with one value if the value is present. If no value is present it will create an emtpy Stream.  With this you could combine the two steps (  filter  and  map  ) to  one  flatMap      final Function Integer, Optional Integer  function\n        = (value) -  (value  = 4) ? Optional.of(value) : Optional.empty();\n\n    final List Integer  collectionJava8 = Stream\n        .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        .map(function) // only to wrap\n        .filter(Optional::isPresent)\n        .map(Optional::get)\n        .collect(Collectors.toList());\n\n    final List Integer  collectionJava9 = Stream\n        .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        .map(function) // only to wrap\n        .flatMap(Optional::stream)\n        .collect(Collectors.toList());\n\n    System.out.println( collectionJava8 =   + collectionJava8);\n    System.out.println( collectionJava9 =   + collectionJava9);", 
            "title": "public Stream stream()"
        }, 
        {
            "location": "/java.util/Optional/#public-optional-orsupplier-extends-optional-extends-t-supplier", 
            "text": "In Java8", 
            "title": "public Optional or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)"
        }, 
        {
            "location": "/java.util/Optional/#public-void-ifpresentorelseconsumer-super-t-action-runnable-emptyaction", 
            "text": "", 
            "title": "public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)"
        }, 
        {
            "location": "/java.util.streams/Stream/", 
            "text": "New Methods inside the Streams API\n\n\nStream\n\n\nWhat are the news from Java8 to Java9?\n\n\ndefault Stream\n dropWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ndropWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ndropWhileParallel = \n + collect);\n  }\n\n\n\n\nThe result will be.\n\n\ndropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]\n\n\n\n\ndefault Stream\n takeWhile(Predicate\n? super T\n predicate)\n\n\n  public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhile.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhile = \n + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List\nInteger\n collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -\n integer \n 5)\n        .collect(Collectors.toList());\n    System.out.println(\ntakeWhileParallel.isEmpty() = \n + collect.isEmpty());\n    System.out.println(\ntakeWhileParallel = \n + collect);\n  }\n\n\n\n\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]\n\n\n\n\npublic static\n Stream\n ofNullable(T t)\n\n\npublic static\n Stream\n iterate(T seed, Predicate\n? super T\n hasNext, UnaryOperator\n next)\n\n\nCollectors\n\n\npublic static \n Collector\n flatMapping(Function\n? super T, ? extends Stream\n? extends U\n mapper,Collector\n? super U, A, R\n downstream)\n\n\npublic static \n Collector\n filtering(Predicate\n? super T\n predicate, Collector\n? super T, A, R\n downstream)\n\n\nIntStream\n\n\nsame as Stream\n\n\npublic static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", 
            "title": "Streams"
        }, 
        {
            "location": "/java.util.streams/Stream/#new-methods-inside-the-streams-api", 
            "text": "", 
            "title": "New Methods inside the Streams API"
        }, 
        {
            "location": "/java.util.streams/Stream/#stream", 
            "text": "What are the news from Java8 to Java9?", 
            "title": "Stream"
        }, 
        {
            "location": "/java.util.streams/Stream/#default-stream-dropwhilepredicate-super-t-predicate", 
            "text": "public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .dropWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( dropWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( dropWhileParallel =   + collect);\n  }  The result will be.  dropWhile.isEmpty() = false\ndropWhile = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhile.isEmpty() = false\ndropWhile = [5, 4, 3, 2, 1]\ndropWhile.isEmpty() = false\ndropWhile = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhile.isEmpty() = false\ndropWhile = [1, 8, 2, 7, 3, 6, 4, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [5, 4, 3, 2, 1]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 9, 2, 8, 3, 7, 4, 6, 5]\ndropWhileParallel.isEmpty() = false\ndropWhileParallel = [1, 8, 2, 7, 3, 6, 4, 5]", 
            "title": "default Stream dropWhile(Predicate&lt;? super T&gt; predicate)"
        }, 
        {
            "location": "/java.util.streams/Stream/#default-stream-takewhilepredicate-super-t-predicate", 
            "text": "public static void main(String[] args) {\n    workOn(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOn(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOn(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOn(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n    workOnParallel(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9});\n    workOnParallel(new Integer[]{9, 8, 7, 6, 5, 4, 3, 2, 1});\n    workOnParallel(new Integer[]{1, 9, 2, 8, 3, 7, 4, 6, 5});\n    workOnParallel(new Integer[]{9, 1, 8, 2, 7, 3, 6, 4, 5});\n  }\n\n  private static void workOn(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhile.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhile =   + collect);\n  }\n  private static void workOnParallel(final Integer[] integers) {\n    final List Integer  collect = Stream\n        .of(integers)\n        .parallel()\n        .takeWhile(integer -  integer   5)\n        .collect(Collectors.toList());\n    System.out.println( takeWhileParallel.isEmpty() =   + collect.isEmpty());\n    System.out.println( takeWhileParallel =   + collect);\n  }  takeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9, 8, 7, 6]\ntakeWhile.isEmpty() = true\ntakeWhile = []\ntakeWhile.isEmpty() = false\ntakeWhile = [9]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9, 8, 7, 6]\ntakeWhileParallel.isEmpty() = true\ntakeWhileParallel = []\ntakeWhileParallel.isEmpty() = false\ntakeWhileParallel = [9]", 
            "title": "default Stream takeWhile(Predicate&lt;? super T&gt; predicate)"
        }, 
        {
            "location": "/java.util.streams/Stream/#public-static-stream-ofnullablet-t", 
            "text": "", 
            "title": "public static Stream ofNullable(T t)"
        }, 
        {
            "location": "/java.util.streams/Stream/#public-static-stream-iteratet-seed-predicate-super-t-hasnext-unaryoperator-next", 
            "text": "", 
            "title": "public static Stream iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator next)"
        }, 
        {
            "location": "/java.util.streams/Stream/#collectors", 
            "text": "", 
            "title": "Collectors"
        }, 
        {
            "location": "/java.util.streams/Stream/#public-static-collector-flatmappingfunction-super-t-extends-stream-extends-u-mappercollector-super-u-a-r-downstream", 
            "text": "", 
            "title": "public static  Collector flatMapping(Function&lt;? super T, ? extends Stream&lt;? extends U&gt;&gt; mapper,Collector&lt;? super U, A, R&gt; downstream)"
        }, 
        {
            "location": "/java.util.streams/Stream/#public-static-collector-filteringpredicate-super-t-predicate-collector-super-t-a-r-downstream", 
            "text": "", 
            "title": "public static  Collector filtering(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, R&gt; downstream)"
        }, 
        {
            "location": "/java.util.streams/Stream/#intstream", 
            "text": "same as Stream", 
            "title": "IntStream"
        }, 
        {
            "location": "/java.util.streams/Stream/#public-static-intstream-iterateint-seed-intpredicate-hasnext-intunaryoperator-next", 
            "text": "", 
            "title": "public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nBlog:\n \nwww.rapidpm.org\n\n\nWeb:\n \nwww.sven-ruppert.de\n\n\nTwitter:\n \n@SvenRuppert\n\n\nLandry:\n \nhttp://lanyrd.com/profile/svenruppert/\n\n\nPublications:\n \nhttp://www.rapidpm.org/publications/index.html\n\n\nTalks:\n \nhttp://www.rapidpm.org/conferences/index.html\n\n\nLinkedin:\n \nhttps://www.linkedin.com/in/svenruppert\n \n\n\nImpressum (for german law)\n\n\nAngaben gem\u00e4\u00df \u00a7 5 TMG:\n\n\nSven Ruppert\n\n\nHans-Keis-Str 41\n\n\n82049\n Pullach\n\n\nKontakt:\n\n\nTelefon:\n    491704546307\n\n\nE-Mail:\n sven.ruppert@gmail.com\n\n\nQuelle: http://www.e-recht24.de\n\n\nHaftungsausschluss (Disclaimer)\n\n\nHaftung f\u00fcr Inhalte\n\n\nAls Diensteanbieter sind wir gem\u00e4\u00df \u00a7 7 Abs.1 TMG f\u00fcr eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach \u00a7\u00a7 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, \u00fcbermittelte oder gespeicherte fremde Informationen zu \u00fcberwachen oder nach Umst\u00e4nden zu forschen, die auf eine rechtswidrige T\u00e4tigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unber\u00fchrt. Eine diesbez\u00fcgliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung m\u00f6glich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen.\n\n\nHaftung f\u00fcr Links\n\n\nUnser Angebot enth\u00e4lt Links zu externen Webseiten Dritter, auf deren Inhalte wir keinen Einfluss haben. Deshalb k\u00f6nnen wir f\u00fcr diese fremden Inhalte auch keine Gew\u00e4hr \u00fcbernehmen. F\u00fcr die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf m\u00f6gliche Rechtsverst\u00f6\u00dfe \u00fcberpr\u00fcft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Links umgehend entfernen.\n\n\nUrheberrecht\n\n\nDie durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielf\u00e4ltigung, Bearbeitung, Verbreitung und jede Art der Verwertung au\u00dferhalb der Grenzen des Urheberrechtes bed\u00fcrfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur f\u00fcr den privaten, nicht kommerziellen Gebrauch gestattet. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitten wir um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Inhalte umgehend entfernen.\n\n\nQuellen: eRecht24\n\n\nDatenschutzerkl\u00e4rung:\n\n\nDatenschutz\n\n\nDie Nutzung unserer Webseite ist in der Regel ohne Angabe personenbezogener Daten m\u00f6glich. Soweit auf unseren Seiten personenbezogene Daten (beispielsweise Name, Anschrift oder eMail-Adressen) erhoben werden, erfolgt dies, soweit m\u00f6glich, stets auf freiwilliger Basis. Diese Daten werden ohne Ihre ausdr\u00fcckliche Zustimmung nicht an Dritte weitergegeben.\n\n\nWir weisen darauf hin, dass die Daten\u00fcbertragung im Internet (z.B. bei der Kommunikation per E-Mail) Sicherheitsl\u00fccken aufweisen kann. Ein l\u00fcckenloser Schutz der Daten vor dem Zugriff durch Dritte ist nicht m\u00f6glich.\n\n\nDer Nutzung von im Rahmen der Impressumspflicht ver\u00f6ffentlichten Kontaktdaten durch Dritte zur \u00dcbersendung von nicht ausdr\u00fccklich angeforderter Werbung und Informationsmaterialien wird hiermit ausdr\u00fccklich widersprochen. Die Betreiber der Seiten behalten sich ausdr\u00fccklich rechtliche Schritte im Falle der unverlangten Zusendung von Werbeinformationen, etwa durch Spam-Mails, vor.\n\n\nDatenschutzerkl\u00e4rung f\u00fcr die Nutzung von Facebook-Plugins (Like-Button)\n\n\nAuf unseren Seiten sind Plugins des sozialen Netzwerks Facebook (Facebook Inc., 1601 Willow Road, Menlo Park, California, 94025, USA) integriert. Die Facebook-Plugins erkennen Sie an dem Facebook-Logo oder dem \"Like-Button\" (\"Gef\u00e4llt mir\") auf unserer Seite. Eine \u00dcbersicht \u00fcber die Facebook-Plugins finden Sie hier: http://developers.facebook.com/docs/plugins/.\nWenn Sie unsere Seiten besuchen, wird \u00fcber das Plugin eine direkte Verbindung zwischen Ihrem Browser und dem Facebook-Server hergestellt. Facebook erh\u00e4lt dadurch die Information, dass Sie mit Ihrer IP-Adresse unsere Seite besucht haben. Wenn Sie den Facebook \"Like-Button\" anklicken w\u00e4hrend Sie in Ihrem Facebook-Account eingeloggt sind, k\u00f6nnen Sie die Inhalte unserer Seiten auf Ihrem Facebook-Profil verlinken. Dadurch kann Facebook den Besuch unserer Seiten Ihrem Benutzerkonto zuordnen. Wir weisen darauf hin, dass wir als Anbieter der Seiten keine Kenntnis vom Inhalt der \u00fcbermittelten Daten sowie deren Nutzung durch Facebook erhalten. Weitere Informationen hierzu finden Sie in der Datenschutzerkl\u00e4rung von facebook unter http://de-de.facebook.com/policy.php\n\n\nWenn Sie nicht w\u00fcnschen, dass Facebook den Besuch unserer Seiten Ihrem Facebook-Nutzerkonto zuordnen kann, loggen Sie sich bitte aus Ihrem Facebook-Benutzerkonto aus.\n\n\nDatenschutzerkl\u00e4rung f\u00fcr die Nutzung von Google Analytics\n\n\nDiese Website benutzt Google Analytics, einen Webanalysedienst der Google Inc. (\"Google\"). Google Analytics verwendet sog. \"Cookies\", Textdateien, die auf Ihrem Computer gespeichert werden und die eine Analyse der Benutzung der Website durch Sie erm\u00f6glichen. Die durch den Cookie erzeugten Informationen \u00fcber Ihre Benutzung dieser Website werden in der Regel an einen Server von Google in den USA \u00fcbertragen und dort gespeichert. Im Falle der Aktivierung der IP-Anonymisierung auf dieser Webseite wird Ihre IP-Adresse von Google jedoch innerhalb von Mitgliedstaaten der Europ\u00e4ischen Union oder in anderen Vertragsstaaten des Abkommens \u00fcber den Europ\u00e4ischen Wirtschaftsraum zuvor gek\u00fcrzt.\n\n\nNur in Ausnahmef\u00e4llen wird die volle IP-Adresse an einen Server von Google in den USA \u00fcbertragen und dort gek\u00fcrzt. Im Auftrag des Betreibers dieser Website wird Google diese Informationen benutzen, um Ihre Nutzung der Website auszuwerten, um Reports \u00fcber die Websiteaktivit\u00e4ten zusammenzustellen und um weitere mit der Websitenutzung und der Internetnutzung verbundene Dienstleistungen gegen\u00fcber dem Websitebetreiber zu erbringen. Die im Rahmen von Google Analytics von Ihrem Browser \u00fcbermittelte IP-Adresse wird nicht mit anderen Daten von Google zusammengef\u00fchrt.\n\n\nSie k\u00f6nnen die Speicherung der Cookies durch eine entsprechende Einstellung Ihrer Browser-Software verhindern; wir weisen Sie jedoch darauf hin, dass Sie in diesem Fall gegebenenfalls nicht s\u00e4mtliche Funktionen dieser Website vollumf\u00e4nglich werden nutzen k\u00f6nnen. Sie k\u00f6nnen dar\u00fcber hinaus die Erfassung der durch das Cookie erzeugten und auf Ihre Nutzung der Website bezogenen Daten (inkl. Ihrer IP-Adresse) an Google sowie die Verarbeitung dieser Daten durch Google verhindern, indem sie das unter dem folgenden Link verf\u00fcgbare Browser-Plugin herunterladen und installieren: http://tools.google.com/dlpage/gaoptout?hl=de.\n\n\nDatenschutzerkl\u00e4rung f\u00fcr die Nutzung von Google Adsense\n\n\nDiese Website benutzt Google AdSense, einen Dienst zum Einbinden von Werbeanzeigen der Google Inc. (\"Google\"). Google AdSense verwendet sog. \"Cookies\", Textdateien, die auf Ihrem Computer gespeichert werden und die eine Analyse der Benutzung der Website erm\u00f6glicht. Google AdSense verwendet auch so genannte Web Beacons (unsichtbare Grafiken). Durch diese Web Beacons k\u00f6nnen Informationen wie der Besucherverkehr auf diesen Seiten ausgewertet werden.\n\n\nDie durch Cookies und Web Beacons erzeugten Informationen \u00fcber die Benutzung dieser Website (einschlie\u00dflich Ihrer IP-Adresse) und Auslieferung von Werbeformaten werden an einen Server von Google in den USA \u00fcbertragen und dort gespeichert. Diese Informationen k\u00f6nnen von Google an Vertragspartner von Google weiter gegeben werden. Google wird Ihre IP-Adresse jedoch nicht mit anderen von Ihnen gespeicherten Daten zusammenf\u00fchren.\n\n\nSie k\u00f6nnen die Installation der Cookies durch eine entsprechende Einstellung Ihrer Browser Software verhindern; wir weisen Sie jedoch darauf hin, dass Sie in diesem Fall gegebenenfalls nicht s\u00e4mtliche Funktionen dieser Website voll umf\u00e4nglich nutzen k\u00f6nnen. Durch die Nutzung dieser Website erkl\u00e4ren Sie sich mit der Bearbeitung der \u00fcber Sie erhobenen Daten durch Google in der zuvor beschriebenen Art und Weise und zu dem zuvor benannten Zweck einverstanden.\n\n\nDatenschutzerkl\u00e4rung f\u00fcr die Nutzung von Google +1\n\n\nErfassung und Weitergabe von Informationen:\nMithilfe der Google +1-Schaltfl\u00e4che k\u00f6nnen Sie Informationen weltweit ver\u00f6ffentlichen. \u00dcber die Google +1-Schaltfl\u00e4che erhalten Sie und andere Nutzer personalisierte Inhalte von Google und unseren Partnern. Google speichert sowohl die Information, dass Sie f\u00fcr einen Inhalt +1 gegeben haben, als auch Informationen \u00fcber die Seite, die Sie beim Klicken auf +1 angesehen haben. Ihre +1 k\u00f6nnen als Hinweise zusammen mit Ihrem Profilnamen und Ihrem Foto in Google-Diensten, wie etwa in Suchergebnissen oder in Ihrem Google-Profil, oder an anderen Stellen auf Websites und Anzeigen im Internet eingeblendet werden.\nGoogle zeichnet Informationen \u00fcber Ihre +1-Aktivit\u00e4ten auf, um die Google-Dienste f\u00fcr Sie und andere zu verbessern. Um die Google +1-Schaltfl\u00e4che verwenden zu k\u00f6nnen, ben\u00f6tigen Sie ein weltweit sichtbares, \u00f6ffentliches Google-Profil, das zumindest den f\u00fcr das Profil gew\u00e4hlten Namen enthalten muss. Dieser Name wird in allen Google-Diensten verwendet. In manchen F\u00e4llen kann dieser Name auch einen anderen Namen ersetzen, den Sie beim Teilen von Inhalten \u00fcber Ihr Google-Konto verwendet haben. Die Identit\u00e4t Ihres Google-Profils kann Nutzern angezeigt werden, die Ihre E-Mail-Adresse kennen oder \u00fcber andere identifizierende Informationen von Ihnen verf\u00fcgen.\n\n\nVerwendung der erfassten Informationen:\nNeben den oben erl\u00e4uterten Verwendungszwecken werden die von Ihnen bereitgestellten Informationen gem\u00e4\u00df den geltenden Google-Datenschutzbestimmungen genutzt. Google ver\u00f6ffentlicht m\u00f6glicherweise zusammengefasste Statistiken \u00fcber die +1-Aktivit\u00e4ten der Nutzer bzw. gibt diese an Nutzer und Partner weiter, wie etwa Publisher, Inserenten oder verbundene Websites.\n\n\nDatenschutzerkl\u00e4rung f\u00fcr die Nutzung von Twitter\n\n\nAuf unseren Seiten sind Funktionen des Dienstes Twitter eingebunden. Diese Funktionen werden angeboten durch die Twitter Inc., Twitter, Inc. 1355 Market St, Suite 900, San Francisco, CA 94103, USA. Durch das Benutzen von Twitter und der Funktion \"Re-Tweet\" werden die von Ihnen besuchten Webseiten mit Ihrem Twitter-Account verkn\u00fcpft und anderen Nutzern bekannt gegeben. Dabei werden auch Daten an Twitter \u00fcbertragen.\n\n\nWir weisen darauf hin, dass wir als Anbieter der Seiten keine Kenntnis vom Inhalt der \u00fcbermittelten Daten sowie deren Nutzung durch Twitter erhalten. Weitere Informationen hierzu finden Sie in der Datenschutzerkl\u00e4rung von Twitter unter http://twitter.com/privacy.\n\n\nIhre Datenschutzeinstellungen bei Twitter k\u00f6nnen Sie in den Konto-Einstellungen unter http://twitter.com/account/settings \u00e4ndern.\n\n\nQuellenangaben: eRecht24, Facebook Datenschutzerkl\u00e4rung, Datenschutzerkl\u00e4rung f\u00fcr Google Analytics, Google Adsense Haftungsausschluss, Google +1 Datenschutzerkl\u00e4rung, Datenschutzerkl\u00e4rung f\u00fcr Twitter", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "Blog:   www.rapidpm.org  Web:   www.sven-ruppert.de  Twitter:   @SvenRuppert  Landry:   http://lanyrd.com/profile/svenruppert/  Publications:   http://www.rapidpm.org/publications/index.html  Talks:   http://www.rapidpm.org/conferences/index.html  Linkedin:   https://www.linkedin.com/in/svenruppert", 
            "title": "About"
        }, 
        {
            "location": "/about/#impressum-for-german-law", 
            "text": "Angaben gem\u00e4\u00df \u00a7 5 TMG:  Sven Ruppert  Hans-Keis-Str 41  82049  Pullach", 
            "title": "Impressum (for german law)"
        }, 
        {
            "location": "/about/#kontakt", 
            "text": "Telefon:     491704546307  E-Mail:  sven.ruppert@gmail.com  Quelle: http://www.e-recht24.de", 
            "title": "Kontakt:"
        }, 
        {
            "location": "/about/#haftungsausschluss-disclaimer", 
            "text": "", 
            "title": "Haftungsausschluss (Disclaimer)"
        }, 
        {
            "location": "/about/#haftung-fur-inhalte", 
            "text": "Als Diensteanbieter sind wir gem\u00e4\u00df \u00a7 7 Abs.1 TMG f\u00fcr eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach \u00a7\u00a7 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, \u00fcbermittelte oder gespeicherte fremde Informationen zu \u00fcberwachen oder nach Umst\u00e4nden zu forschen, die auf eine rechtswidrige T\u00e4tigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unber\u00fchrt. Eine diesbez\u00fcgliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung m\u00f6glich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen.", 
            "title": "Haftung f\u00fcr Inhalte"
        }, 
        {
            "location": "/about/#haftung-fur-links", 
            "text": "Unser Angebot enth\u00e4lt Links zu externen Webseiten Dritter, auf deren Inhalte wir keinen Einfluss haben. Deshalb k\u00f6nnen wir f\u00fcr diese fremden Inhalte auch keine Gew\u00e4hr \u00fcbernehmen. F\u00fcr die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf m\u00f6gliche Rechtsverst\u00f6\u00dfe \u00fcberpr\u00fcft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Links umgehend entfernen.", 
            "title": "Haftung f\u00fcr Links"
        }, 
        {
            "location": "/about/#urheberrecht", 
            "text": "Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielf\u00e4ltigung, Bearbeitung, Verbreitung und jede Art der Verwertung au\u00dferhalb der Grenzen des Urheberrechtes bed\u00fcrfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur f\u00fcr den privaten, nicht kommerziellen Gebrauch gestattet. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitten wir um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Inhalte umgehend entfernen.  Quellen: eRecht24", 
            "title": "Urheberrecht"
        }, 
        {
            "location": "/about/#datenschutzerklarung", 
            "text": "", 
            "title": "Datenschutzerkl\u00e4rung:"
        }, 
        {
            "location": "/about/#datenschutz", 
            "text": "Die Nutzung unserer Webseite ist in der Regel ohne Angabe personenbezogener Daten m\u00f6glich. Soweit auf unseren Seiten personenbezogene Daten (beispielsweise Name, Anschrift oder eMail-Adressen) erhoben werden, erfolgt dies, soweit m\u00f6glich, stets auf freiwilliger Basis. Diese Daten werden ohne Ihre ausdr\u00fcckliche Zustimmung nicht an Dritte weitergegeben.  Wir weisen darauf hin, dass die Daten\u00fcbertragung im Internet (z.B. bei der Kommunikation per E-Mail) Sicherheitsl\u00fccken aufweisen kann. Ein l\u00fcckenloser Schutz der Daten vor dem Zugriff durch Dritte ist nicht m\u00f6glich.  Der Nutzung von im Rahmen der Impressumspflicht ver\u00f6ffentlichten Kontaktdaten durch Dritte zur \u00dcbersendung von nicht ausdr\u00fccklich angeforderter Werbung und Informationsmaterialien wird hiermit ausdr\u00fccklich widersprochen. Die Betreiber der Seiten behalten sich ausdr\u00fccklich rechtliche Schritte im Falle der unverlangten Zusendung von Werbeinformationen, etwa durch Spam-Mails, vor.", 
            "title": "Datenschutz"
        }, 
        {
            "location": "/about/#datenschutzerklarung-fur-die-nutzung-von-facebook-plugins-like-button", 
            "text": "Auf unseren Seiten sind Plugins des sozialen Netzwerks Facebook (Facebook Inc., 1601 Willow Road, Menlo Park, California, 94025, USA) integriert. Die Facebook-Plugins erkennen Sie an dem Facebook-Logo oder dem \"Like-Button\" (\"Gef\u00e4llt mir\") auf unserer Seite. Eine \u00dcbersicht \u00fcber die Facebook-Plugins finden Sie hier: http://developers.facebook.com/docs/plugins/.\nWenn Sie unsere Seiten besuchen, wird \u00fcber das Plugin eine direkte Verbindung zwischen Ihrem Browser und dem Facebook-Server hergestellt. Facebook erh\u00e4lt dadurch die Information, dass Sie mit Ihrer IP-Adresse unsere Seite besucht haben. Wenn Sie den Facebook \"Like-Button\" anklicken w\u00e4hrend Sie in Ihrem Facebook-Account eingeloggt sind, k\u00f6nnen Sie die Inhalte unserer Seiten auf Ihrem Facebook-Profil verlinken. Dadurch kann Facebook den Besuch unserer Seiten Ihrem Benutzerkonto zuordnen. Wir weisen darauf hin, dass wir als Anbieter der Seiten keine Kenntnis vom Inhalt der \u00fcbermittelten Daten sowie deren Nutzung durch Facebook erhalten. Weitere Informationen hierzu finden Sie in der Datenschutzerkl\u00e4rung von facebook unter http://de-de.facebook.com/policy.php  Wenn Sie nicht w\u00fcnschen, dass Facebook den Besuch unserer Seiten Ihrem Facebook-Nutzerkonto zuordnen kann, loggen Sie sich bitte aus Ihrem Facebook-Benutzerkonto aus.", 
            "title": "Datenschutzerkl\u00e4rung f\u00fcr die Nutzung von Facebook-Plugins (Like-Button)"
        }, 
        {
            "location": "/about/#datenschutzerklarung-fur-die-nutzung-von-google-analytics", 
            "text": "Diese Website benutzt Google Analytics, einen Webanalysedienst der Google Inc. (\"Google\"). Google Analytics verwendet sog. \"Cookies\", Textdateien, die auf Ihrem Computer gespeichert werden und die eine Analyse der Benutzung der Website durch Sie erm\u00f6glichen. Die durch den Cookie erzeugten Informationen \u00fcber Ihre Benutzung dieser Website werden in der Regel an einen Server von Google in den USA \u00fcbertragen und dort gespeichert. Im Falle der Aktivierung der IP-Anonymisierung auf dieser Webseite wird Ihre IP-Adresse von Google jedoch innerhalb von Mitgliedstaaten der Europ\u00e4ischen Union oder in anderen Vertragsstaaten des Abkommens \u00fcber den Europ\u00e4ischen Wirtschaftsraum zuvor gek\u00fcrzt.  Nur in Ausnahmef\u00e4llen wird die volle IP-Adresse an einen Server von Google in den USA \u00fcbertragen und dort gek\u00fcrzt. Im Auftrag des Betreibers dieser Website wird Google diese Informationen benutzen, um Ihre Nutzung der Website auszuwerten, um Reports \u00fcber die Websiteaktivit\u00e4ten zusammenzustellen und um weitere mit der Websitenutzung und der Internetnutzung verbundene Dienstleistungen gegen\u00fcber dem Websitebetreiber zu erbringen. Die im Rahmen von Google Analytics von Ihrem Browser \u00fcbermittelte IP-Adresse wird nicht mit anderen Daten von Google zusammengef\u00fchrt.  Sie k\u00f6nnen die Speicherung der Cookies durch eine entsprechende Einstellung Ihrer Browser-Software verhindern; wir weisen Sie jedoch darauf hin, dass Sie in diesem Fall gegebenenfalls nicht s\u00e4mtliche Funktionen dieser Website vollumf\u00e4nglich werden nutzen k\u00f6nnen. Sie k\u00f6nnen dar\u00fcber hinaus die Erfassung der durch das Cookie erzeugten und auf Ihre Nutzung der Website bezogenen Daten (inkl. Ihrer IP-Adresse) an Google sowie die Verarbeitung dieser Daten durch Google verhindern, indem sie das unter dem folgenden Link verf\u00fcgbare Browser-Plugin herunterladen und installieren: http://tools.google.com/dlpage/gaoptout?hl=de.", 
            "title": "Datenschutzerkl\u00e4rung f\u00fcr die Nutzung von Google Analytics"
        }, 
        {
            "location": "/about/#datenschutzerklarung-fur-die-nutzung-von-google-adsense", 
            "text": "Diese Website benutzt Google AdSense, einen Dienst zum Einbinden von Werbeanzeigen der Google Inc. (\"Google\"). Google AdSense verwendet sog. \"Cookies\", Textdateien, die auf Ihrem Computer gespeichert werden und die eine Analyse der Benutzung der Website erm\u00f6glicht. Google AdSense verwendet auch so genannte Web Beacons (unsichtbare Grafiken). Durch diese Web Beacons k\u00f6nnen Informationen wie der Besucherverkehr auf diesen Seiten ausgewertet werden.  Die durch Cookies und Web Beacons erzeugten Informationen \u00fcber die Benutzung dieser Website (einschlie\u00dflich Ihrer IP-Adresse) und Auslieferung von Werbeformaten werden an einen Server von Google in den USA \u00fcbertragen und dort gespeichert. Diese Informationen k\u00f6nnen von Google an Vertragspartner von Google weiter gegeben werden. Google wird Ihre IP-Adresse jedoch nicht mit anderen von Ihnen gespeicherten Daten zusammenf\u00fchren.  Sie k\u00f6nnen die Installation der Cookies durch eine entsprechende Einstellung Ihrer Browser Software verhindern; wir weisen Sie jedoch darauf hin, dass Sie in diesem Fall gegebenenfalls nicht s\u00e4mtliche Funktionen dieser Website voll umf\u00e4nglich nutzen k\u00f6nnen. Durch die Nutzung dieser Website erkl\u00e4ren Sie sich mit der Bearbeitung der \u00fcber Sie erhobenen Daten durch Google in der zuvor beschriebenen Art und Weise und zu dem zuvor benannten Zweck einverstanden.", 
            "title": "Datenschutzerkl\u00e4rung f\u00fcr die Nutzung von Google Adsense"
        }, 
        {
            "location": "/about/#datenschutzerklarung-fur-die-nutzung-von-google-1", 
            "text": "Erfassung und Weitergabe von Informationen:\nMithilfe der Google +1-Schaltfl\u00e4che k\u00f6nnen Sie Informationen weltweit ver\u00f6ffentlichen. \u00dcber die Google +1-Schaltfl\u00e4che erhalten Sie und andere Nutzer personalisierte Inhalte von Google und unseren Partnern. Google speichert sowohl die Information, dass Sie f\u00fcr einen Inhalt +1 gegeben haben, als auch Informationen \u00fcber die Seite, die Sie beim Klicken auf +1 angesehen haben. Ihre +1 k\u00f6nnen als Hinweise zusammen mit Ihrem Profilnamen und Ihrem Foto in Google-Diensten, wie etwa in Suchergebnissen oder in Ihrem Google-Profil, oder an anderen Stellen auf Websites und Anzeigen im Internet eingeblendet werden.\nGoogle zeichnet Informationen \u00fcber Ihre +1-Aktivit\u00e4ten auf, um die Google-Dienste f\u00fcr Sie und andere zu verbessern. Um die Google +1-Schaltfl\u00e4che verwenden zu k\u00f6nnen, ben\u00f6tigen Sie ein weltweit sichtbares, \u00f6ffentliches Google-Profil, das zumindest den f\u00fcr das Profil gew\u00e4hlten Namen enthalten muss. Dieser Name wird in allen Google-Diensten verwendet. In manchen F\u00e4llen kann dieser Name auch einen anderen Namen ersetzen, den Sie beim Teilen von Inhalten \u00fcber Ihr Google-Konto verwendet haben. Die Identit\u00e4t Ihres Google-Profils kann Nutzern angezeigt werden, die Ihre E-Mail-Adresse kennen oder \u00fcber andere identifizierende Informationen von Ihnen verf\u00fcgen.  Verwendung der erfassten Informationen:\nNeben den oben erl\u00e4uterten Verwendungszwecken werden die von Ihnen bereitgestellten Informationen gem\u00e4\u00df den geltenden Google-Datenschutzbestimmungen genutzt. Google ver\u00f6ffentlicht m\u00f6glicherweise zusammengefasste Statistiken \u00fcber die +1-Aktivit\u00e4ten der Nutzer bzw. gibt diese an Nutzer und Partner weiter, wie etwa Publisher, Inserenten oder verbundene Websites.", 
            "title": "Datenschutzerkl\u00e4rung f\u00fcr die Nutzung von Google +1"
        }, 
        {
            "location": "/about/#datenschutzerklarung-fur-die-nutzung-von-twitter", 
            "text": "Auf unseren Seiten sind Funktionen des Dienstes Twitter eingebunden. Diese Funktionen werden angeboten durch die Twitter Inc., Twitter, Inc. 1355 Market St, Suite 900, San Francisco, CA 94103, USA. Durch das Benutzen von Twitter und der Funktion \"Re-Tweet\" werden die von Ihnen besuchten Webseiten mit Ihrem Twitter-Account verkn\u00fcpft und anderen Nutzern bekannt gegeben. Dabei werden auch Daten an Twitter \u00fcbertragen.  Wir weisen darauf hin, dass wir als Anbieter der Seiten keine Kenntnis vom Inhalt der \u00fcbermittelten Daten sowie deren Nutzung durch Twitter erhalten. Weitere Informationen hierzu finden Sie in der Datenschutzerkl\u00e4rung von Twitter unter http://twitter.com/privacy.  Ihre Datenschutzeinstellungen bei Twitter k\u00f6nnen Sie in den Konto-Einstellungen unter http://twitter.com/account/settings \u00e4ndern.  Quellenangaben: eRecht24, Facebook Datenschutzerkl\u00e4rung, Datenschutzerkl\u00e4rung f\u00fcr Google Analytics, Google Adsense Haftungsausschluss, Google +1 Datenschutzerkl\u00e4rung, Datenschutzerkl\u00e4rung f\u00fcr Twitter", 
            "title": "Datenschutzerkl\u00e4rung f\u00fcr die Nutzung von Twitter"
        }
    ]
}